<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>factory_bot</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Intro</a></li><li class="chapter-item expanded "><a href="ref/build-strategies.html"><strong aria-hidden="true">1.</strong> Build strategies</a></li><li class="chapter-item expanded "><a href="ref/find_definitions.html"><strong aria-hidden="true">2.</strong> FactoryBot.find_definitions</a></li><li class="chapter-item expanded "><a href="ref/define.html"><strong aria-hidden="true">3.</strong> FactoryBot.define</a></li><li class="chapter-item expanded "><a href="ref/factory.html"><strong aria-hidden="true">4.</strong> factory</a></li><li class="chapter-item expanded "><a href="ref/add_attribute.html"><strong aria-hidden="true">5.</strong> add_attribute</a></li><li class="chapter-item expanded "><a href="ref/association.html"><strong aria-hidden="true">6.</strong> association</a></li><li class="chapter-item expanded "><a href="ref/sequence.html"><strong aria-hidden="true">7.</strong> sequence</a></li><li class="chapter-item expanded "><a href="ref/trait.html"><strong aria-hidden="true">8.</strong> trait</a></li><li class="chapter-item expanded "><a href="ref/method_missing.html"><strong aria-hidden="true">9.</strong> method_missing</a></li><li class="chapter-item expanded "><a href="ref/traits_for_enum.html"><strong aria-hidden="true">10.</strong> traits_for_enum</a></li><li class="chapter-item expanded "><a href="ref/build-and-create.html"><strong aria-hidden="true">11.</strong> skip_create, to_create, and initialize_with</a></li><li class="chapter-item expanded "><a href="ref/transient.html"><strong aria-hidden="true">12.</strong> transient</a></li><li class="chapter-item expanded "><a href="ref/hooks.html"><strong aria-hidden="true">13.</strong> Hooks</a></li><li class="chapter-item expanded "><a href="ref/modify.html"><strong aria-hidden="true">14.</strong> FactoryBot.modify</a></li><li class="chapter-item expanded "><a href="ref/lint.html"><strong aria-hidden="true">15.</strong> FactoryBot.lint</a></li><li class="chapter-item expanded "><a href="ref/register_strategy.html"><strong aria-hidden="true">16.</strong> FactoryBot.register_strategy</a></li><li class="chapter-item expanded "><a href="setup/summary.html"><strong aria-hidden="true">17.</strong> Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="using-without-bundler/summary.html"><strong aria-hidden="true">17.1.</strong> Using Without Bundler</a></li><li class="chapter-item expanded "><a href="rails-preloaders-and-rspec/summary.html"><strong aria-hidden="true">17.2.</strong> Rails Preloaders and RSpec</a></li></ol></li><li class="chapter-item expanded "><a href="defining/summary.html"><strong aria-hidden="true">18.</strong> Defining factories</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="defining/name-attributes.html"><strong aria-hidden="true">18.1.</strong> Factory name and attributes</a></li><li class="chapter-item expanded "><a href="defining/explicit-class.html"><strong aria-hidden="true">18.2.</strong> Specifying the class explicitly</a></li><li class="chapter-item expanded "><a href="defining/file-paths.html"><strong aria-hidden="true">18.3.</strong> Definition file paths</a></li><li class="chapter-item expanded "><a href="defining/hash-attributes.html"><strong aria-hidden="true">18.4.</strong> Hash attributes</a></li><li class="chapter-item expanded "><a href="defining/best-practices.html"><strong aria-hidden="true">18.5.</strong> Best practices</a></li><li class="chapter-item expanded "><a href="defining/static-attributes.html"><strong aria-hidden="true">18.6.</strong> Static Attributes (deprecated)</a></li></ol></li><li class="chapter-item expanded "><a href="using-factories/summary.html"><strong aria-hidden="true">19.</strong> Using factories</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="using-factories/build-strategies.html"><strong aria-hidden="true">19.1.</strong> Build strategies</a></li><li class="chapter-item expanded "><a href="building-or-creating-multiple-records/summary.html"><strong aria-hidden="true">19.2.</strong> Building or Creating Multiple Records</a></li><li class="chapter-item expanded "><a href="using-factories/attribute-overrides.html"><strong aria-hidden="true">19.3.</strong> Attribute overrides</a></li></ol></li><li class="chapter-item expanded "><a href="aliases/summary.html"><strong aria-hidden="true">20.</strong> Aliases</a></li><li class="chapter-item expanded "><a href="dependent-attributes/summary.html"><strong aria-hidden="true">21.</strong> Dependent Attributes</a></li><li class="chapter-item expanded "><a href="transient-attributes/summary.html"><strong aria-hidden="true">22.</strong> Transient Attributes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="transient-attributes/with-other-attributes.html"><strong aria-hidden="true">22.1.</strong> With other attributes</a></li><li class="chapter-item expanded "><a href="transient-attributes/with-attributes_for.html"><strong aria-hidden="true">22.2.</strong> With attributes_for</a></li><li class="chapter-item expanded "><a href="transient-attributes/with-callbacks.html"><strong aria-hidden="true">22.3.</strong> With callbacks</a></li><li class="chapter-item expanded "><a href="transient-attributes/with-associations.html"><strong aria-hidden="true">22.4.</strong> With associations</a></li></ol></li><li class="chapter-item expanded "><a href="method-name-reserved-word-attributes/summary.html"><strong aria-hidden="true">23.</strong> Method Name / Reserved Word Attributes</a></li><li class="chapter-item expanded "><a href="inheritance/summary.html"><strong aria-hidden="true">24.</strong> Inheritance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="inheritance/nested-factories.html"><strong aria-hidden="true">24.1.</strong> Nested factories</a></li><li class="chapter-item expanded "><a href="inheritance/assigning-parent-explicitly.html"><strong aria-hidden="true">24.2.</strong> Assigning parent explicitly</a></li><li class="chapter-item expanded "><a href="inheritance/best-practices.html"><strong aria-hidden="true">24.3.</strong> Best practices</a></li></ol></li><li class="chapter-item expanded "><a href="associations/summary.html"><strong aria-hidden="true">25.</strong> Associations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="associations/implicit-definition.html"><strong aria-hidden="true">25.1.</strong> Implicit definition</a></li><li class="chapter-item expanded "><a href="associations/explicit-definition.html"><strong aria-hidden="true">25.2.</strong> Explicit definition</a></li><li class="chapter-item expanded "><a href="associations/inline-definition.html"><strong aria-hidden="true">25.3.</strong> Inline definition</a></li><li class="chapter-item expanded "><a href="associations/specifying-the-factory.html"><strong aria-hidden="true">25.4.</strong> Specifying the factory</a></li><li class="chapter-item expanded "><a href="associations/overriding-attributes.html"><strong aria-hidden="true">25.5.</strong> Overriding attributes</a></li><li class="chapter-item expanded "><a href="associations/association-overrides.html"><strong aria-hidden="true">25.6.</strong> Association overrides</a></li><li class="chapter-item expanded "><a href="associations/build-strategies.html"><strong aria-hidden="true">25.7.</strong> Build strategies</a></li></ol></li><li class="chapter-item expanded "><a href="sequences/summary.html"><strong aria-hidden="true">26.</strong> Sequences</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sequences/global-sequences.html"><strong aria-hidden="true">26.1.</strong> Global sequences</a></li><li class="chapter-item expanded "><a href="sequences/with-dynamic-attributes.html"><strong aria-hidden="true">26.2.</strong> With dynamic attributes</a></li><li class="chapter-item expanded "><a href="sequences/as-implicit-attributes.html"><strong aria-hidden="true">26.3.</strong> As implicit attributes</a></li><li class="chapter-item expanded "><a href="sequences/factory-sequences.html"><strong aria-hidden="true">26.4.</strong> Factory sequences</a></li><li class="chapter-item expanded "><a href="sequences/initial-value.html"><strong aria-hidden="true">26.5.</strong> Initial value</a></li><li class="chapter-item expanded "><a href="sequences/without-a-block.html"><strong aria-hidden="true">26.6.</strong> Without a block</a></li><li class="chapter-item expanded "><a href="sequences/aliases.html"><strong aria-hidden="true">26.7.</strong> Aliases</a></li><li class="chapter-item expanded "><a href="sequences/sequence-uris.html"><strong aria-hidden="true">26.8.</strong> Sequence URIs</a></li><li class="chapter-item expanded "><a href="sequences/rewinding.html"><strong aria-hidden="true">26.9.</strong> Rewinding</a></li><li class="chapter-item expanded "><a href="sequences/setting-the-value.html"><strong aria-hidden="true">26.10.</strong> Setting the value</a></li><li class="chapter-item expanded "><a href="sequences/generating.html"><strong aria-hidden="true">26.11.</strong> Generating a sequence</a></li><li class="chapter-item expanded "><a href="sequences/uniqueness.html"><strong aria-hidden="true">26.12.</strong> Uniqueness</a></li></ol></li><li class="chapter-item expanded "><a href="traits/summary.html"><strong aria-hidden="true">27.</strong> Traits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="traits/as-implicit-attributes.html"><strong aria-hidden="true">27.1.</strong> As implicit attributes</a></li><li class="chapter-item expanded "><a href="traits/using.html"><strong aria-hidden="true">27.2.</strong> Using traits</a></li><li class="chapter-item expanded "><a href="traits/enum.html"><strong aria-hidden="true">27.3.</strong> Enum traits</a></li><li class="chapter-item expanded "><a href="traits/attribute-precedence.html"><strong aria-hidden="true">27.4.</strong> Attribute precedence</a></li><li class="chapter-item expanded "><a href="traits/in-child-factories.html"><strong aria-hidden="true">27.5.</strong> In child factories</a></li><li class="chapter-item expanded "><a href="traits/mixins.html"><strong aria-hidden="true">27.6.</strong> As mixins</a></li><li class="chapter-item expanded "><a href="traits/with-associations.html"><strong aria-hidden="true">27.7.</strong> With associations</a></li><li class="chapter-item expanded "><a href="traits/traits-within-traits.html"><strong aria-hidden="true">27.8.</strong> Traits within traits</a></li><li class="chapter-item expanded "><a href="traits/with-transient-attributes.html"><strong aria-hidden="true">27.9.</strong> With transient attributes</a></li></ol></li><li class="chapter-item expanded "><a href="callbacks/summary.html"><strong aria-hidden="true">28.</strong> Callbacks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="callbacks/multiple-callbacks.html"><strong aria-hidden="true">28.1.</strong> Multiple callbacks</a></li><li class="chapter-item expanded "><a href="callbacks/global-callbacks.html"><strong aria-hidden="true">28.2.</strong> Global callbacks</a></li><li class="chapter-item expanded "><a href="callbacks/symbol-to_proc.html"><strong aria-hidden="true">28.3.</strong> Symbol#to_proc</a></li><li class="chapter-item expanded "><a href="callbacks/callback_order.html"><strong aria-hidden="true">28.4.</strong> Callback order</a></li></ol></li><li class="chapter-item expanded "><a href="modifying-factories/summary.html"><strong aria-hidden="true">29.</strong> Modifying factories</a></li><li class="chapter-item expanded "><a href="linting-factories/summary.html"><strong aria-hidden="true">30.</strong> Linting Factories</a></li><li class="chapter-item expanded "><a href="custom-construction/summary.html"><strong aria-hidden="true">31.</strong> Custom Construction</a></li><li class="chapter-item expanded "><a href="custom-strategies/summary.html"><strong aria-hidden="true">32.</strong> Custom Strategies</a></li><li class="chapter-item expanded "><a href="custom-callbacks/summary.html"><strong aria-hidden="true">33.</strong> Custom Callbacks</a></li><li class="chapter-item expanded "><a href="custom-methods-to-persist-objects/summary.html"><strong aria-hidden="true">34.</strong> Custom Methods to Persist Objects</a></li><li class="chapter-item expanded "><a href="activesupport-instrumentation/summary.html"><strong aria-hidden="true">35.</strong> ActiveSupport Instrumentation</a></li><li class="chapter-item expanded "><a href="cookbook/has_many-associations.html"><strong aria-hidden="true">36.</strong> has_many associations</a></li><li class="chapter-item expanded "><a href="cookbook/has_and_belongs_to_many-associations.html"><strong aria-hidden="true">37.</strong> has_and_belongs_to_many associations</a></li><li class="chapter-item expanded "><a href="cookbook/polymorphic-associations.html"><strong aria-hidden="true">38.</strong> Polymorphic associations</a></li><li class="chapter-item expanded "><a href="cookbook/interconnected-associations.html"><strong aria-hidden="true">39.</strong> Interconnected associations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">factory_bot</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>factory_bot is a fixtures replacement with a straightforward definition syntax,
support for multiple build strategies (saved instances, unsaved instances,
attribute hashes, and stubbed objects), and support for multiple factories for
the same class (user, admin_user, and so on), including factory inheritance.</p>
<p>Its documentation is split as such:</p>
<ul>
<li>the <a href="setup/summary.html">guide</a> is a great place to start for first-time users.</li>
<li>the <a href="cookbook/has_many-associations.html">cookbook</a> is the go-to place for creative solutions to common situations.</li>
<li>the <a href="https://github.com/thoughtbot/factory_bot/wiki">wiki</a> details considerations for integrating with other software.</li>
<li>the <a href="ref/build-strategies.html">reference</a> is terse facts for those who use this project often.</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>factory_bot is Copyright Â© 2008 Joe Ferris and thoughtbot. It is free
software, and may be redistributed under the terms specified in the
<a href="https://github.com/thoughtbot/factory_bot/blob/main/LICENSE">LICENSE</a> file.</p>
<h2 id="about-thoughtbot"><a class="header" href="#about-thoughtbot">About thoughtbot</a></h2>
<p>factory_bot is maintained and funded by thoughtbot, inc.
The names and logos for thoughtbot are trademarks of thoughtbot, inc.</p>
<p>We love open source software!
See <a href="https://thoughtbot.com/community?utm_source=github">our other projects</a> or
<a href="https://thoughtbot.com/hire-us?utm_source=github">hire us</a> to design, develop, and grow your product.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-strategies"><a class="header" href="#build-strategies">Build strategies</a></h1>
<p>Once a factory_bot factory is defined, it can be constructed using any of the
built-in build strategies, or a custom build strategy.</p>
<p>All of these strategies notify on the <code>factory_bot.run_factory</code>
instrumentation using <a href="https://api.rubyonrails.org/classes/ActiveSupport/Notifications.html">ActiveSupport::Notifications</a>, passing a payload with
<code>:name</code>, <code>:strategy</code>, <code>:traits</code>, <code>:overrides</code>, and <code>:factory</code> keys.</p>
<p>The non-list (<code>.build</code>, <code>.build_pair</code>, <code>.create</code>, etc.) methods take one
mandatory argument: the name of the factory. They can then optionally take
names of traits, and then a hash of attributes to override. Finally, they can
take a block. This block takes the produced object as an argument, and returns
an updated object.</p>
<p>The list methods (<code>.build_list</code>, <code>.create_list</code>, etc.) have two required
arguments: the name of the factory, and the number of instances to build. They
then can optionally take traits and overrides. Finally, they can take a block.
This block takes the produced object and the zero-based index as arguments, and
returns an updated object.</p>
<h2 id="build"><a class="header" href="#build"><code>build</code></a></h2>
<p>The <code>FactoryBot.build</code> method constructs an instance of the class according to
<code>initialize_with</code>, which defaults to calling the <code>.new</code> class method.
<code>.build_list</code> constructs multiple instances, and <code>.build_pair</code> is a shorthand
to construct two instances.</p>
<p>After it calls <code>initialize_with</code>, it invokes the <code>after_build</code> hook.</p>
<p>Associations are constructed using the <code>build</code> build strategy.</p>
<h2 id="create"><a class="header" href="#create"><code>create</code></a></h2>
<p>The <code>FactoryBot.create</code> method constructs an instance of the class according to
<code>initialize_with</code>, and then persists it using <code>to_create</code>. The <code>.create_list</code>
class method constructs multiple instances, and <code>.create_pair</code> is a shorthand
to construct two instances.</p>
<p>After it calls <code>initialize_with</code>, it invokes the following hooks in order:</p>
<ol>
<li><code>after_build</code></li>
<li><code>before_create</code></li>
<li>non-hook: <code>to_create</code></li>
<li><code>after_create</code></li>
</ol>
<p>Associations are constructed using the <code>create</code> build strategy.</p>
<p>The <code>to_create</code> hook controls how objects are persisted. It takes a block with
the object and the factory_bot context, and runs it for its side effect. By
default, it calls <code>#save!</code>.</p>
<h2 id="attributes_for"><a class="header" href="#attributes_for"><code>attributes_for</code></a></h2>
<p>The <code>FactoryBot.attributes_for</code> method constructs a Hash with the attributes
and their values, using <code>initialize_with</code>. The <code>attributes_for_pair</code> and
<code>attributes_for_list</code> methods work similarly as <code>build_pair</code> and <code>build_list</code>.</p>
<p>Associations are constructed using the <code>null</code> build strategy (they are not built).</p>
<p>No hooks are called.</p>
<h2 id="build_stubbed"><a class="header" href="#build_stubbed"><code>build_stubbed</code></a></h2>
<p>The <code>FactoryBot.build_stubbed</code> method returns a fake ActiveRecord object. The
<code>.build_stubbed_pair</code> and <code>.build_stubbed_list</code> methods are defined similarly
to <code>.build_pair</code> and <code>.build_list</code>.</p>
<p>It uses <code>initialize_with</code> to construct the object, but then stubs methods and
data as appropriate:</p>
<ul>
<li><code>id</code> is set sequentially (unless overridden by attributes)</li>
<li><code>created_at</code> and <code>updated_at</code> are set to the current time (unless overridden by attributes)</li>
<li>all <a href="https://api.rubyonrails.org/classes/ActiveModel/Dirty.html">ActiveModel::Dirty</a> change tracking is cleared</li>
<li><code>persisted?</code> is true</li>
<li><code>new_record?</code> is false</li>
<li><code>destroyed?</code> is false</li>
<li>persistence methods raise a <code>RuntimeError</code> (<code>#connection</code>, <code>#delete</code>, <code>#save</code>, <code>#update</code>, etc.)</li>
</ul>
<p>After it sets up the object it invokes the <code>after_stub</code> hook.</p>
<h2 id="null"><a class="header" href="#null"><code>null</code></a></h2>
<p>The <code>FactoryBot.null</code> method returns <code>nil</code>. The <code>.null_pair</code> method gives you a
pair of nils, and <code>.null_list</code> gives as many nils as you desire. This is used
internally.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorybotfind_definitions"><a class="header" href="#factorybotfind_definitions">FactoryBot.find_definitions</a></h1>
<p>The <code>FactoryBot.find_definitions</code> method loads in all factory_bot definitions
across the project.</p>
<p>The load order is controlled by the <code>FactoryBot.definition_file_paths</code>
attribute. The default load order is:</p>
<ol>
<li><code>factories.rb</code></li>
<li><code>factories/**/*.rb</code></li>
<li><code>test/factories.rb</code></li>
<li><code>test/factories/**/*.rb</code></li>
<li><code>spec/factories.rb</code></li>
<li><code>spec/factories/**/*.rb</code></li>
</ol>
<h2 id="rails"><a class="header" href="#rails">Rails</a></h2>
<p>The <code>.find_definitions</code> method is called automatically by <code>factory_bot_rails</code>
after initialize. The <code>.definition_file_paths</code> can be set during initialization
(e.g. <code>config/initializers</code>), or via
<code>Rails.application.config.factory_bot.definition_file_paths</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorybotdefine"><a class="header" href="#factorybotdefine">FactoryBot.define</a></h1>
<p>Each file loaded by factory_bot is expected to call <code>FactoryBot.define</code> with a
block. The block is evaluated within an instance of
<code>FactoryBot::Syntax::Default::DSL</code>, giving access to <code>factory</code>, <code>sequence</code>,
<code>trait</code>, and other methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory"><a class="header" href="#factory">factory</a></h1>
<p>Within a <code>FactoryBot.define</code> block, you can define factories. Anything defined
using <code>factory</code> can be built using a <a href="ref/build-strategies.html">build strategy</a>.</p>
<p>The <code>factory</code> method takes three arguments: a required name, an optional hash
of options, and an optional block.</p>
<p>The name is expected to be a Symbol.</p>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<ul>
<li><code>:class</code> - what class to construct. This can be either a class, or a String
or Symbol (anything that responds to <code>#to_s</code>). By default it is either the
parent's class name or the factory's name.</li>
<li><code>:parent</code>- the name of another factory that this factory should inherit from.
Defaults to <code>nil</code>.</li>
<li><code>:aliases</code> - alternative names for this factory. Any of these names can be
used with a build strategy. Defaults to the empty list.</li>
<li><code>:traits</code> - base traits that are used by default when building this factory.
Defaults to the empty list.</li>
</ul>
<h2 id="block"><a class="header" href="#block">Block</a></h2>
<p>You can use the block to define your factory. Within here you have access to the following methods:</p>
<ul>
<li><a href="ref/add_attribute.html"><code>add_attribute</code></a></li>
<li><a href="ref/association.html"><code>association</code></a></li>
<li><a href="ref/sequence.html"><code>sequence</code></a></li>
<li><a href="ref/trait.html"><code>trait</code></a></li>
<li><a href="ref/method_missing.html"><code>method_missing</code></a></li>
<li><a href="ref/transient.html"><code>transient</code></a></li>
<li><a href="ref/traits_for_enum.html"><code>traits_for_enum</code></a></li>
<li><a href="ref/build-and-create.html#initialize_with"><code>initialize_with</code></a></li>
<li><a href="ref/build-and-create.html"><code>skip_create</code></a></li>
<li><a href="ref/build-and-create.html#to_create"><code>to_create</code></a></li>
<li><a href="ref/hooks.html#after-and-before-methods"><code>before</code></a></li>
<li><a href="ref/hooks.html#after-and-before-methods"><code>after</code></a></li>
<li><a href="ref/hooks.html#callback"><code>callback</code></a></li>
<li><code>factory</code></li>
</ul>
<p>You can use <code>factory</code> inside a <code>factory</code> block to define a new factory with an
implied parent.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add_attribute"><a class="header" href="#add_attribute">add_attribute</a></h1>
<p>Within a factory definition, the <code>add_attribute</code> method defines a key/value
pair that will be set when the object is built.</p>
<p>The <code>add_attribute</code> method takes two arguments: a name (Symbol or String) and a
block. This block is called each time this object is constructed. The block is
not called when the attribute is overridden by a build strategy.</p>
<p>Assignment is done by calling the Ruby attribute setter. For example, given</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :user do
    add_attribute(:name) { &quot;Acid Burn&quot; }
  end
end
</code></pre>
<p>This will use the <code>#name=</code> setter:</p>
<pre><code class="language-ruby">user = User.new
user.name = &quot;Acid Burn&quot;
</code></pre>
<p>Also see <a href="ref/method_missing.html">method_missing</a> for a shorthand.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="association"><a class="header" href="#association">association</a></h1>
<p>Within a factory block, use the <code>association</code> method to always make an
additional object alongside this one. This name best makes sense within the
context of ActiveRecord.</p>
<p>The <code>association</code> method takes a mandatory name and optional options.</p>
<p>The options are zero or more trait names (Symbols), followed by a hash
of attribute overrides. When constructing this association, factory_bot uses
the trait and attribute overrides given.</p>
<p>See <a href="ref/method_missing.html">method_missing</a> for a shorthand. See <a href="ref/build-strategies.html">build
strategies</a> for an explanation of how each build
strategy handles associations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence"><a class="header" href="#sequence">sequence</a></h1>
<p>A factory_bot set up supports two levels of sequences: global and factory-specific.</p>
<h2 id="global-sequences"><a class="header" href="#global-sequences">Global sequences</a></h2>
<p>With a <a href="ref/define.html"><code>Factory.define</code></a> block, use the <code>sequence</code> method to define global
sequences that can be shared with other factories.</p>
<p>The <code>sequence</code> method takes a name, optional arguments, and a block. The name
is expected to be a Symbol.</p>
<p>The supported arguments are a number representing the starting value (default:
<code>1</code>), and <code>:aliases</code> (default <code>[]</code>). The starting value must respond to <code>#next</code>.</p>
<p>The block takes a value as an argument, and returns a result.</p>
<p>The sequence value is incremented globally. Using an <code>:email_address</code> sequence
from multiple places increments the value each time.</p>
<p>See <a href="ref/method_missing.html">method_missing</a> for a shorthand.</p>
<h2 id="factory-sequences"><a class="header" href="#factory-sequences">Factory sequences</a></h2>
<p>Sequences can be localized within <code>factory</code> blocks. The syntax is the same as
for a global sequence, but the scope of the incremented value is limited to the
factory definition.</p>
<p>In addition, using <code>sequence</code> with a <code>factory</code> block implicitly calls
<code>add_attribute</code> for that value.</p>
<p>These two are similar, except the second example does not cause any global
sequences to exist:</p>
<pre><code class="language-ruby"># A global sequence
sequence(:user_factory_email) { |n| &quot;person#{n}@example.com&quot; }

factory :user do
  # Using a global sequence
  email { generate(:user_factory_email) }
end
</code></pre>
<pre><code class="language-ruby"># A factory-scoped sequence
factory :user do
  sequence(:email) { |n| &quot;person#{n}@example.com&quot; }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">trait</a></h1>
<p>Within a <code>factory</code> definition block, use the <code>trait</code> method to define named permutations of the factory.</p>
<p>The trait method takes a name (Symbol) and a block. Treat the block like you
would a <a href="ref/factory.html"><code>factory</code></a> definition block.</p>
<p>See <a href="ref/method_missing.html">method_missing</a> for a shorthand.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method_missing"><a class="header" href="#method_missing">method_missing</a></h1>
<p>With a <code>factory</code> definition block, you can use <code>add_attribute</code>, <code>association</code>,
<code>sequence</code>, and <code>trait</code> to define a factory. You can also level a default
<code>method_missing</code> definition for potential shortcuts.</p>
<p>Calling an unknown method (e.g. <code>name</code>, <code>admin</code>, <code>email</code>, <code>account</code>) connects
an association, sequence, trait, or attribute to the factory:</p>
<ol>
<li>
<p>If the method missing is passed a block, it always defines an attribute.
This allows you to set the value for the attribute.</p>
</li>
<li>
<p>If the method missing is passed a hash as a argument with the key
<code>:factory</code>, then it always defines an association. This allows you to
override the factory used for the association.</p>
</li>
<li>
<p>If there is another factory of the same name, then it defines an
association.</p>
</li>
<li>
<p>If there is a global sequence of the same name, then it defines an attribute
with a value that pulls from the sequence.</p>
</li>
<li>
<p>If there is a trait of the same name for that factory, then it turns that
trait on for all builds of this factory.</p>
</li>
</ol>
<p>Using <code>method_missing</code> can turn an explicit definition:</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence(:email) { |n| &quot;person#{n}@example.com&quot; }
  factory :account
  factory :organization

  factory :user, traits: [:admin] do
    add_attribute(:name) { &quot;Lord Nikon&quot; }
    add_attribute(:email) { generate(:email) }
    association :account
    association :org, factory: :organization

    trait :admin do
      add_attribute(:admin) { true }
    end
  end
end
</code></pre>
<p>... into a more implicit definition:</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence(:email) { |n| &quot;person#{n}@example.com&quot; }
  factory :account
  factory :organization

  factory :user do
    name { &quot;Lord Nikon&quot; }      # no more `add_attribute`
    admin                      # no more :traits
    email                      # no more `add_attribute`
    account                    # no more `association`
    org factory: :organization # no more `association`

    trait :admin do
      admin { true }
    end
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits_for_enum"><a class="header" href="#traits_for_enum">traits_for_enum</a></h1>
<p>With a <code>factory</code> definition block, the <code>traits_for_enum</code> method is a helper for
any object with an attribute that can be one of a few values. The original
inspiration was <a href="https://api.rubyonrails.org/classes/ActiveRecord/Enum.html"><code>ActiveRecord::Enum</code></a> but it can apply to any attribute with a
restricted set of values.</p>
<p>This method creates a trait for each value.</p>
<p>The <code>traits_for_enum</code> method takes a required attribute name and an optional
set of values. The values can be any Enumerable, such as Array or Hash. By
default, the values are <code>nil</code>.</p>
<p>If the values are an Array, this method defines a trait for each element in the
array. The trait's name is the array element, and it sets the attribute to the
same array element.</p>
<p>If the values are a Hash, this method defines traits based on the keys,
setting the attribute to the values. The trait's name is the key, and it sets
the attribute to the value.</p>
<p>If the value is any other Enumerable, it treats it like an Array or Hash based
on whether <code>#each</code> iterates in pairs like it does for Hashes.</p>
<p>If the value is nil, it uses a class method named after the pluralized
attribute name.</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :article do
    traits_for_enum :visibility, [:public, :private]
    # trait :public do
    #   visibility { :public }
    # end
    # trait :private do
    #   visibility { :private }
    # end

    traits_for_enum :collaborative, draft: 0, shared: 1
    # trait :draft do
    #   collaborative { 0 }
    # end
    # trait :shared do
    #   collaborative { 1 }
    # end

    traits_for_enum :status
    # Article.statuses.each do |key, value|
    #   trait key do
    #     status { value }
    #   end
    # end
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="skip_create-to_create-and-initialize_with"><a class="header" href="#skip_create-to_create-and-initialize_with">skip_create, to_create, and initialize_with</a></h1>
<p>The <code>skip_create</code>, <code>to_create</code>, and <code>initialize_with</code> methods control how
factory_bot interacts with the <a href="ref/build-strategies.html">build strategies</a>.</p>
<p>These methods can be called within a <code>factory</code> definition block, to scope their
effects to just that factory; or within <code>FactoryBot.define</code>, to affect global
change.</p>
<h2 id="initialize_with"><a class="header" href="#initialize_with">initialize_with</a></h2>
<p>The <code>initialize_with</code> method takes a block and returns an instance of the
factory's class. It has access to the <code>attributes</code> method, which is a hash of
all the fields and values for the object.</p>
<p>The default definition is:</p>
<pre><code class="language-ruby">initialize_with { new }
</code></pre>
<h2 id="to_create"><a class="header" href="#to_create">to_create</a></h2>
<p>The <code>to_create</code> method lets you control the <code>FactoryBot.create</code> strategy. This
method takes a block which takes the object as constructed by
<code>initialize_with</code>, and the factory_bot context. The context has additional
data from any <a href="ref/transient.html"><code>transient</code></a> blocks.</p>
<p>The default definition is:</p>
<pre><code class="language-ruby">to_create { |obj, context| obj.save! }
</code></pre>
<p>The <code>skip_create</code> method is a shorthand for turning <code>to_create</code> into a no-op.
This allows you to use the <code>create</code> strategy as a synonym for <code>build</code>, except
you additionally get any <code>create</code> hooks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transient"><a class="header" href="#transient">transient</a></h1>
<p>Within a <code>factory</code> definition block, the goal is to construct an instance of
the class. While factory_bot does this, it keeps track of data in a
context. To set data on this context, use a <code>transient</code> block.</p>
<p>Treat a <code>transient</code> block like a <code>factory</code> definition block. However, none of
the attributes, associations, traits, or sequences you set will impact the
final object.</p>
<p>This is most useful when paired with <a href="ref/hooks.html">hooks</a> or
<a href="ref/build-and-create.html">to_create</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks"><a class="header" href="#hooks">Hooks</a></h1>
<p>Within a <code>factory</code> definition block and the <code>FactoryBot.define</code> block, you have
access to the <code>after</code>, <code>before</code>, and <code>callback</code> methods. This allow you to hook
into parts of the <a href="ref/build-strategies.html">build strategies</a>.</p>
<p>Within a <code>factory</code> definition block, these callbacks are scoped to just that
factory. Within a <code>FactoryBot.define</code> block, they are global to all factories.</p>
<h2 id="callback"><a class="header" href="#callback"><code>callback</code></a></h2>
<p>The <code>callback</code> method allows you to hook into any factory_bot callback by
name. The pre-defined names, as seen in the <a href="ref/build-strategies.html">build strategies</a> reference, are
<code>before_all</code>, <code>after_build</code>, <code>before_create</code>, <code>after_create</code>, <code>after_stub</code>, and <code>after_all</code>.</p>
<p>This method takes a splat of names, and a block. It invokes the block any time
one of the names is activated. The block can be anything that responds to
<code>#to_proc</code>.</p>
<p>This block takes two arguments: the instance of the factory, and the
factory_bot context. The context holds <a href="ref/transient.html">transient</a>
attributes.</p>
<p>The same callback name can be hooked into multiple times. Every block is run,
in the order it was defined. Callbacks are inherited from their parents; the
parents' callbacks are run first.</p>
<h2 id="after-and-before-methods"><a class="header" href="#after-and-before-methods"><code>after</code> and <code>before</code> methods</a></h2>
<p>The <code>after</code> and <code>before</code> methods add some nice syntax to <code>callback</code>:</p>
<pre><code class="language-ruby">after(:create) do |user, context|
  user.post_first_article(context.article)
end

callback(:after_create) do |user, context|
  user.post_first_article(context.article)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorybotmodify"><a class="header" href="#factorybotmodify">FactoryBot.modify</a></h1>
<p>The <code>FactoryBot.modify</code> class method defines a block with an <em>overriding</em>
<code>factory</code> method available. That is the only method you can call within the
block.</p>
<p>The <code>factory</code> method within this block takes a mandatory factory name, and a
block. All other arguments are ignored. The factory name must already be
defined. The block is a normal <a href="ref/factory.html">factory definition block</a>. Take
note that <a href="ref/hooks.html">hooks</a> cannot be cleared and continue to compound.</p>
<p>For details on why you'd want to use this, see <a href="ref/../modifying-factories/summary.html">the
guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorybotlint"><a class="header" href="#factorybotlint">FactoryBot.lint</a></h1>
<p>The <code>FactoryBot.lint</code> method tries each factory and raises
<code>FactoryBot::InvalidFactoryError</code> on failure.</p>
<p>It can take the following optional arguments:</p>
<ul>
<li>A splat of factory names. This will restrict the linting to just the ones listed. The default is all.</li>
<li><code>:strategy</code> - the <a href="ref/build-strategies.html">build strategy</a> to use. The default is <code>:create</code>.</li>
<li><code>:traits</code> - whether to try building each trait, too. The default is <code>false</code>.</li>
<li><code>:verbose</code> - whether to show a stack trace on error. The default is <code>false</code>.</li>
</ul>
<p>Suggested techniques for hooking <code>.lint</code> into your system is discussed in <a href="ref/../linting-factories/summary.html">the
guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorybotregister_strategy"><a class="header" href="#factorybotregister_strategy">FactoryBot.register_strategy</a></h1>
<p>The <code>FactoryBot.register_strategy</code> method is how to add a <a href="ref/build-strategies.html">build
strategy</a>.</p>
<p>It takes two mandatory arguments: name and class. The name is a Symbol, and
registering it exposes a method under <code>FactoryBot::Syntax::Methods</code>.</p>
<p>The class must define the methods <code>association</code> and <code>result</code>.</p>
<p>The <code>association</code> method takes an instance of <code>FactoryRunner</code>. You can <code>#run</code>
this runner, passing a strategy name (it defaults to the current one) and an
optional block. The block is called after the association is built, and is
passed the object that was built.</p>
<p>The <code>result</code> method takes the object that was built for this factory (using
<code>initalize_with</code>), and returns the result of this factory for this build
strategy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>Installation varies based on the framework you are using, if any, and
optionally the test framework.</p>
<p>Since installation varies based on code that we do not control, those docs are
kept up-to-date in <a href="https://github.com/thoughtbot/factory_bot/wiki/Installation">our wiki</a>. We encourage you to edit the wiki as the
frameworks change.</p>
<p>Below we document the most common setup. However, <strong>we go into more detail in
<a href="https://github.com/thoughtbot/factory_bot/wiki/Installation">our wiki</a></strong>.</p>
<h2 id="update-your-gemfile"><a class="header" href="#update-your-gemfile">Update Your Gemfile</a></h2>
<p>If you're using Rails:</p>
<pre><code class="language-ruby">gem &quot;factory_bot_rails&quot;
</code></pre>
<p>If you're <em>not</em> using Rails:</p>
<pre><code class="language-ruby">gem &quot;factory_bot&quot;
</code></pre>
<p>For more, see <a href="https://github.com/thoughtbot/factory_bot/wiki/Installation">our wiki</a>.</p>
<h2 id="configure-your-test-suite"><a class="header" href="#configure-your-test-suite">Configure your test suite</a></h2>
<h3 id="rspec"><a class="header" href="#rspec">RSpec</a></h3>
<pre><code class="language-ruby">RSpec.configure do |config|
  config.include FactoryBot::Syntax::Methods
end
</code></pre>
<h3 id="testunit"><a class="header" href="#testunit">Test::Unit</a></h3>
<pre><code class="language-ruby">class Test::Unit::TestCase
  include FactoryBot::Syntax::Methods
end
</code></pre>
<p>For more, see <a href="https://github.com/thoughtbot/factory_bot/wiki/Installation">our wiki</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-without-bundler"><a class="header" href="#using-without-bundler">Using Without Bundler</a></h1>
<p>If you're not using Bundler, be sure to have the gem installed and call:</p>
<pre><code class="language-ruby">require 'factory_bot'
</code></pre>
<p>Once required, assuming you have a directory structure of <code>spec/factories</code> or
<code>test/factories</code>, all you'll need to do is run:</p>
<pre><code class="language-ruby">FactoryBot.find_definitions
</code></pre>
<p>If you're using a separate directory structure for your factories, you can
change the definition file paths before trying to find definitions:</p>
<pre><code class="language-ruby">FactoryBot.definition_file_paths = %w(custom_factories_directory)
FactoryBot.find_definitions
</code></pre>
<p>If you don't have a separate directory of factories and would like to define
them inline, that's possible as well:</p>
<pre><code class="language-ruby">require 'factory_bot'

FactoryBot.define do
  factory :user do
    name { 'John Doe' }
    date_of_birth { 21.years.ago }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rails-preloaders-and-rspec"><a class="header" href="#rails-preloaders-and-rspec">Rails Preloaders and RSpec</a></h1>
<p>When running RSpec with a Rails preloader such as <code>spring</code> or <code>zeus</code>, it's
possible to encounter an <code>ActiveRecord::AssociationTypeMismatch</code> error when
creating a factory with associations, as below:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :united_states, class: &quot;Location&quot; do
    name { 'United States' }
    association :location_group, factory: :north_america
  end

  factory :north_america, class: &quot;LocationGroup&quot; do
    name { 'North America' }
  end
end
</code></pre>
<p>The error occurs during the run of the test suite:</p>
<pre><code>Failure/Error: united_states = create(:united_states)
ActiveRecord::AssociationTypeMismatch:
  LocationGroup(#70251250797320) expected, got LocationGroup(#70251200725840)
</code></pre>
<p>The two possible solutions are to either run the suite without the preloader,
or to add <code>FactoryBot.reload</code> to the RSpec configuration, like so:</p>
<pre><code class="language-ruby">RSpec.configure do |config|
  config.before(:suite) { FactoryBot.reload }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-factories"><a class="header" href="#defining-factories">Defining factories</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory-name-and-attributes"><a class="header" href="#factory-name-and-attributes">Factory name and attributes</a></h1>
<p>Each factory has a name and a set of attributes. The name is used to guess the
class of the object by default:</p>
<pre><code class="language-ruby"># This will guess the User class
FactoryBot.define do
  factory :user do
    first_name { &quot;John&quot; }
    last_name  { &quot;Doe&quot; }
    admin { false }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifying-the-class-explicitly"><a class="header" href="#specifying-the-class-explicitly">Specifying the class explicitly</a></h1>
<p>It is also possible to explicitly specify the class:</p>
<pre><code class="language-ruby"># This will use the User class (otherwise Admin would have been guessed)
factory :admin, class: &quot;User&quot;
</code></pre>
<p>You can pass a constant as well, if the constant is available (note that this
can cause test performance problems in large Rails applications, since
referring to the constant will cause it to be eagerly loaded).</p>
<pre><code class="language-ruby">factory :access_token, class: User
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definition-file-paths"><a class="header" href="#definition-file-paths">Definition file paths</a></h1>
<p>Factories can be defined anywhere, but will be automatically loaded after
calling <code>FactoryBot.find_definitions</code> if factories are defined in files at the
following locations:</p>
<pre><code>factories.rb
factories/**/*.rb
test/factories.rb
test/factories/**/*.rb
spec/factories.rb
spec/factories/**/*.rb
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-attributes"><a class="header" href="#hash-attributes">Hash attributes</a></h1>
<p>Because of the block syntax in Ruby, defining attributes as <code>Hash</code>es (for
serialized/JSON columns, for example) requires two sets of curly brackets:</p>
<pre><code class="language-ruby">factory :program do
  configuration { { auto_resolve: false, auto_define: true } }
end
</code></pre>
<p>Alternatively you may prefer <code>do</code>/<code>end</code> syntax:</p>
<pre><code class="language-ruby">factory :program do
  configuration do
    { auto_resolve: false, auto_define: true }
  end
end
</code></pre>
<hr />
<p>However, defining a value as a hash makes it complicated to set values within
the hash when constructing an object. Instead, prefer to use factory_bot
itself:</p>
<pre><code class="language-ruby">factory :program do
  configuration { attributes_for(:configuration) }
end

factory :configuration do
  auto_resolve { false }
  auto_define { true }
end
</code></pre>
<p>This way you can more easily set value when building:</p>
<pre><code class="language-ruby">create(
  :program,
  configuration: attributes_for(
    :configuration,
    auto_resolve: true,
  )
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices"><a class="header" href="#best-practices">Best practices</a></h1>
<p>It is recommended that you have one factory for each class that provides
the simplest set of attributes necessary to create an instance of that class. If
you're creating ActiveRecord objects, that means that you should only provide
attributes that are required through validations and that do not have defaults.
Other factories can be created through inheritance to cover common scenarios for
each class.</p>
<p>Attempting to define multiple factories with the same name will raise an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-attributes"><a class="header" href="#static-attributes">Static Attributes</a></h1>
<p>Static attributes (without a block) are no longer available in factory_bot 5.
You can read more about the decision to remove them in
<a href="https://robots.thoughtbot.com/deprecating-static-attributes-in-factory_bot-4-11">this blog post</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-factories"><a class="header" href="#using-factories">Using factories</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-strategies-1"><a class="header" href="#build-strategies-1">Build strategies</a></h1>
<p>factory_bot supports several different build strategies: <code>build</code>, <code>create</code>,
<code>attributes_for</code> and <code>build_stubbed</code>:</p>
<pre><code class="language-ruby"># Returns a User instance that's not saved
user = build(:user)

# Returns a saved User instance
user = create(:user)

# Returns a hash of attributes, which can be used to build a User instance for example
attrs = attributes_for(:user)

# Integrates with Ruby 3.0's support for pattern matching assignment
attributes_for(:user) =&gt; {email:, name:, **attrs}

# Returns an object with all defined attributes stubbed out
stub = build_stubbed(:user)

# Passing a block to any of the methods above will yield the return object
create(:user) do |user|
  user.posts.create(attributes_for(:post))
end
</code></pre>
<h1 id="build_stubbed-and-marshaldump"><a class="header" href="#build_stubbed-and-marshaldump">build_stubbed and Marshal.dump</a></h1>
<p>Note that objects created with <code>build_stubbed</code> cannot be serialized with
<code>Marshal.dump</code>, since factory_bot defines singleton methods on these objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-or-creating-multiple-records"><a class="header" href="#building-or-creating-multiple-records">Building or Creating Multiple Records</a></h1>
<p>Sometimes, you'll want to create or build multiple instances of a factory at
once.</p>
<pre><code class="language-ruby">built_users   = build_list(:user, 25)
created_users = create_list(:user, 25)
</code></pre>
<p>These methods will build or create a specific amount of factories and return
them as an array. To set the attributes for each of the factories, you can pass
in a hash as you normally would.</p>
<pre><code class="language-ruby">twenty_year_olds = build_list(:user, 25, date_of_birth: 20.years.ago)
</code></pre>
<p>In order to set different attributes for each factory, these methods may be
passed a block, with the factory and the index as parameters:</p>
<pre><code class="language-ruby">twenty_somethings = build_list(:user, 10) do |user, i|
  user.date_of_birth = (20 + i).years.ago
end
</code></pre>
<p><code>create_list</code> passes saved instances into the block. If you modify the
instance, you must save it again:</p>
<pre><code class="language-ruby">twenty_somethings = create_list(:user, 10) do |user, i|
  user.date_of_birth = (20 + i).years.ago
  user.save!
end
</code></pre>
<p><code>build_stubbed_list</code> will give you fully stubbed out instances:</p>
<pre><code class="language-ruby">stubbed_users = build_stubbed_list(:user, 25) # array of stubbed users
</code></pre>
<p>There's also a set of <code>*_pair</code> methods for creating two records at a time:</p>
<pre><code class="language-ruby">built_users   = build_pair(:user) # array of two built users
created_users = create_pair(:user) # array of two created users
</code></pre>
<p>If you need multiple attribute hashes, <code>attributes_for_list</code> will generate
them:</p>
<pre><code class="language-ruby">users_attrs = attributes_for_list(:user, 25) # array of attribute hashes
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attribute-overrides"><a class="header" href="#attribute-overrides">Attribute overrides</a></h1>
<p>No matter which strategy is used, it's possible to override the defined
attributes by passing a hash:</p>
<pre><code class="language-ruby"># Build a User instance and override the first_name property
user = build(:user, first_name: &quot;Joe&quot;)
user.first_name
# =&gt; &quot;Joe&quot;
</code></pre>
<p>Ruby 3.1's support for <a href="https://docs.ruby-lang.org/en/3.1/syntax/literals_rdoc.html#label-Hash+Literals">omitting values</a> from <code>Hash</code> literals dovetails with
attribute overrides and provides an opportunity to limit the repetition of
variable names:</p>
<pre><code class="language-ruby">first_name = &quot;Joe&quot;

# Build a User instance and override the first_name property
user = build(:user, first_name:)
user.first_name
# =&gt; &quot;Joe&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aliases"><a class="header" href="#aliases">Aliases</a></h1>
<p>factory_bot allows you to define aliases to existing factories to make them
easier to re-use. This could come in handy when, for example, your Post object
has an author attribute that actually refers to an instance of a User class.
While normally factory_bot can infer the factory name from the association name,
in this case it will look for an author factory in vain. So, alias your user
factory so it can be used under alias names.</p>
<pre><code class="language-ruby">factory :user, aliases: [:author, :commenter] do
  first_name { &quot;John&quot; }
  last_name { &quot;Doe&quot; }
  date_of_birth { 18.years.ago }
end

factory :post do
  # The alias allows us to write author instead of
  # association :author, factory: :user
  author
  title { &quot;How to read a book effectively&quot; }
  body { &quot;There are five steps involved.&quot; }
end

factory :comment do
  # The alias allows us to write commenter instead of
  # association :commenter, factory: :user
  commenter
  body { &quot;Great article!&quot; }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependent-attributes"><a class="header" href="#dependent-attributes">Dependent Attributes</a></h1>
<p>Attributes can be based on the values of other attributes using the context
that is yielded to dynamic attribute blocks:</p>
<pre><code class="language-ruby">factory :user do
  first_name { &quot;Joe&quot; }
  last_name  { &quot;Blow&quot; }
  email { &quot;#{first_name}.#{last_name}@example.com&quot;.downcase }
end

create(:user, last_name: &quot;Doe&quot;).email
# =&gt; &quot;joe.doe@example.com&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transient-attributes"><a class="header" href="#transient-attributes">Transient Attributes</a></h1>
<p>Transient attributes are attributes only available within the factory
definition, and not set on the object being built. This allows for more complex
logic inside factories.</p>
<p>These are defined within a <code>transient</code> block:</p>
<pre><code class="language-ruby">factory :user do
  name { &quot;Zero Cool&quot; }
  birth_date { age&amp;.years.ago }

  transient do
    age { 11 } # only used to set `birth_date` above
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-other-attributes"><a class="header" href="#with-other-attributes">With other attributes</a></h1>
<p>You can access transient attributes within other attributes (see <a href="transient-attributes/../dependent-attributes/summary.html">Dependent
Attributes</a>):</p>
<pre><code class="language-ruby">factory :user do
  transient do
    rockstar { true }
  end

  name { &quot;John Doe#{&quot; - Rockstar&quot; if rockstar}&quot; }
end

create(:user).name
#=&gt; &quot;John Doe - ROCKSTAR&quot;

create(:user, rockstar: false).name
#=&gt; &quot;John Doe&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-attributes_for"><a class="header" href="#with-attributes_for">With attributes_for</a></h1>
<p>Transient attributes will be ignored within <code>attributes_for</code> and won't be set
on the model, even if the attribute exists or you attempt to override it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-callbacks"><a class="header" href="#with-callbacks">With callbacks</a></h1>
<p>If you need to access the evaluated definition itself in a factory_bot callback, you'll
need to declare a second block argument (for the definition) and access transient
attributes from there. This represents the final, evaluated value.</p>
<pre><code class="language-ruby">factory :user do
  transient do
    upcased { false }
  end

  name { &quot;John Doe&quot; }

  after(:create) do |user, context|
    user.name.upcase! if context.upcased
  end
end

create(:user).name
#=&gt; &quot;John Doe&quot;

create(:user, upcased: true).name
#=&gt; &quot;JOHN DOE&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-associations"><a class="header" href="#with-associations">With associations</a></h1>
<p>Transient <a href="transient-attributes/../associations/summary.html">associations</a> are not supported in
factory_bot. Associations within the transient block will be treated as
regular, non-transient associations.</p>
<p>If needed, you can generally work around this by building a factory within a
transient attribute:</p>
<pre><code class="language-ruby">factory :post

factory :user do
  transient do
    post { build(:post) }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-name--reserved-word-attributes"><a class="header" href="#method-name--reserved-word-attributes">Method Name / Reserved Word Attributes</a></h1>
<p>If your attributes conflict with existing methods or reserved words (all
methods in the
<a href="https://github.com/thoughtbot/factory_bot/blob/main/lib/factory_bot/definition_proxy.rb">DefinitionProxy</a>
class) you can define them with <code>add_attribute</code>.</p>
<pre><code class="language-ruby">factory :dna do
  add_attribute(:sequence) { 'GATTACA' }
end

factory :payment do
  add_attribute(:method) { 'paypal' }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-factories"><a class="header" href="#nested-factories">Nested factories</a></h1>
<p>You can create multiple factories for the same class without repeating common
attributes by nesting factories:</p>
<pre><code class="language-ruby">factory :post do
  title { &quot;A title&quot; }

  factory :approved_post do
    approved { true }
  end
end

approved_post = create(:approved_post)
approved_post.title    # =&gt; &quot;A title&quot;
approved_post.approved # =&gt; true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assigning-parent-explicitly"><a class="header" href="#assigning-parent-explicitly">Assigning parent explicitly</a></h1>
<p>You can also assign the parent explicitly:</p>
<pre><code class="language-ruby">factory :post do
  title { &quot;A title&quot; }
end

factory :approved_post, parent: :post do
  approved { true }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices-1"><a class="header" href="#best-practices-1">Best practices</a></h1>
<p>As mentioned above, it's good practice to define a basic factory for each class
with only the attributes required to create it. Then, create more specific
factories that inherit from this basic parent.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associations"><a class="header" href="#associations">Associations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicit-definition"><a class="header" href="#implicit-definition">Implicit definition</a></h1>
<p>It's possible to set up associations within factories. If the factory name is
the same as the association name, the factory name can be left out.</p>
<pre><code class="language-ruby">factory :post do
  # ...
  author
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explicit-definition"><a class="header" href="#explicit-definition">Explicit definition</a></h1>
<p>You can define associations explicitly. This can be handy especially when
<a href="associations/overriding-attributes.html">Overriding attributes</a></p>
<pre><code class="language-ruby">factory :post do
  # ...
  association :author
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-definition"><a class="header" href="#inline-definition">Inline definition</a></h1>
<p>You can also define associations inline within regular attributes, but note
that the value will be <code>nil</code> when using the <code>attributes_for</code> strategy.</p>
<pre><code class="language-ruby">factory :post do
  # ...
  author { association :author }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifying-the-factory"><a class="header" href="#specifying-the-factory">Specifying the factory</a></h1>
<p>You can specify a different factory (although <a href="associations/../aliases/summary.html">Aliases</a>
might also help you out here).</p>
<p>Implicitly:</p>
<pre><code class="language-ruby">factory :post do
  # ...
  author factory: :user
end
</code></pre>
<p>Explicitly:</p>
<pre><code class="language-ruby">factory :post do
  # ...
  association :author, factory: :user
end
</code></pre>
<p>Inline:</p>
<pre><code class="language-ruby">factory :post do
  # ...
  author { association :user }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overriding-attributes"><a class="header" href="#overriding-attributes">Overriding attributes</a></h1>
<p>You can also override attributes on associations.</p>
<p>Implicitly:</p>
<pre><code class="language-ruby">factory :post do
  # ...
  author factory: :author, last_name: &quot;Writely&quot;
end
</code></pre>
<p>Explicitly:</p>
<pre><code class="language-ruby">factory :post do
  # ...
  association :author, last_name: &quot;Writely&quot;
end
</code></pre>
<p>Or inline using attributes from the factory:</p>
<pre><code class="language-rb">factory :post do
  # ...
  author_last_name { &quot;Writely&quot; }
  author { association :author, last_name: author_last_name }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="association-overrides"><a class="header" href="#association-overrides">Association overrides</a></h1>
<p>Attribute overrides can be used to link associated objects:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :author do
    name { 'Taylor' }
  end

  factory :post do
    author
  end
end

eunji = build(:author, name: 'Eunji')
post = build(:post, author: eunji)
</code></pre>
<p>Ruby 3.1's support for <a href="https://docs.ruby-lang.org/en/3.1/syntax/literals_rdoc.html#label-Hash+Literals">omitting values</a> from <code>Hash</code> literals dovetails with
attribute overrides, and provides an opportunity to limit the repetition of
variable names:</p>
<pre><code class="language-ruby">author = build(:author, name: 'Eunji')

post = build(:post, author:)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-strategies-2"><a class="header" href="#build-strategies-2">Build strategies</a></h1>
<p>Associations default to using the same build strategy as their parent object:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :author

  factory :post do
    author
  end
end

post = build(:post)
post.new_record?        # =&gt; true
post.author.new_record? # =&gt; true

post = create(:post)
post.new_record?        # =&gt; false
post.author.new_record? # =&gt; false
</code></pre>
<p>This is different than the default behavior for previous versions of
factory_bot, where the association strategy would not always match the strategy
of the parent object. If you want to continue using the old behavior, you can
set the <code>use_parent_strategy</code> configuration option to <code>false</code>.</p>
<pre><code class="language-ruby">FactoryBot.use_parent_strategy = false

# Builds and saves a User and a Post
post = create(:post)
post.new_record?        # =&gt; false
post.author.new_record? # =&gt; false

# Builds and saves a User, and then builds but does not save a Post
post = build(:post)
post.new_record?        # =&gt; true
post.author.new_record? # =&gt; false
</code></pre>
<p>To not save the associated object, specify <code>strategy: :build</code> in the factory:</p>
<pre><code class="language-ruby">FactoryBot.use_parent_strategy = false

factory :post do
  # ...
  association :author, factory: :user, strategy: :build
end

# Builds a User, and then builds a Post, but does not save either
post = build(:post)
post.new_record?        # =&gt; true
post.author.new_record? # =&gt; true
</code></pre>
<p>Note that the <code>strategy: :build</code> option must be passed to an explicit call to
<code>association</code>, and cannot be used with implicit associations:</p>
<pre><code class="language-ruby">factory :post do
  # ...
  author strategy: :build    # &lt;&lt;&lt; this does *not* work; causes author_id to be nil
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequences"><a class="header" href="#sequences">Sequences</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-sequences-1"><a class="header" href="#global-sequences-1">Global sequences</a></h1>
<p>Unique values in a specific format (for example, e-mail addresses) can be
generated using sequences. Sequences are defined by calling <code>sequence</code> in a
definition block, and values in a sequence are generated by calling <code>generate</code>:</p>
<pre><code class="language-ruby"># Defines a new sequence
FactoryBot.define do
  sequence :email do |n|
    &quot;person#{n}@example.com&quot;
  end
end

generate :email
# =&gt; &quot;person1@example.com&quot;

generate :email
# =&gt; &quot;person2@example.com&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-dynamic-attributes"><a class="header" href="#with-dynamic-attributes">With dynamic attributes</a></h1>
<p>Sequences can be used in dynamic attributes:</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence :email do |n|
    &quot;person#{n}@example.com&quot;
  end
end

factory :invite do
  invitee { generate(:email) }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-implicit-attributes"><a class="header" href="#as-implicit-attributes">As implicit attributes</a></h1>
<p>Or as implicit attributes:</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence :email do |n|
    &quot;person#{n}@example.com&quot;
  end
end

factory :user do
  email # Same as `email { generate(:email) }`
end
</code></pre>
<p>Note that defining sequences as implicit attributes will not work if you have a
factory with the same name as the sequence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory-sequences-1"><a class="header" href="#factory-sequences-1">Factory sequences</a></h1>
<p>And it's also possible to define a sequence that is only used in
a particular factory:</p>
<pre><code class="language-ruby">factory :user do
  sequence(:email) { |n| &quot;person#{n}@example.com&quot; }
end
</code></pre>
<p>With Ruby 2.7's support for <a href="https://ruby-doc.org/core-2.7.1/Proc.html#class-Proc-label-Numbered+parameters">numbered parameters</a>, inline definitions can be
even more abbreviated:</p>
<pre><code class="language-ruby">factory :user do
  sequence(:email) { &quot;person#{_1}@example.com&quot; }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-value"><a class="header" href="#initial-value">Initial value</a></h1>
<p>You can override the initial value. Any value that responds to the <code>#next</code>
method will work (e.g. 1, 2, 3, 'a', 'b', 'c')</p>
<pre><code class="language-ruby">factory :user do
  sequence(:email, 1000) { |n| &quot;person#{n}@example.com&quot; }
end
</code></pre>
<p>The initial value can also be lazily set by passing a Proc as the value. This Proc will be called the first time the <code>sequence.next</code> is called.</p>
<pre><code class="language-ruby">factory :user do
  sequence(:email, proc { Person.count + 1 }) { |n| &quot;person#{n}@example.com&quot; }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="without-a-block"><a class="header" href="#without-a-block">Without a block</a></h1>
<p>Without a block, the value will increment itself, starting at its initial value:</p>
<pre><code class="language-ruby">factory :post do
  sequence(:position)
end
</code></pre>
<p>Note that the value for the sequence could be any Enumerable instance, as long
as it responds to <code>#next</code>:</p>
<pre><code class="language-ruby">factory :task do
  sequence :priority, %i[low medium high urgent].cycle
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aliases-1"><a class="header" href="#aliases-1">Aliases</a></h1>
<p>Sequences can also have aliases. The sequence aliases share the same counter:</p>
<pre><code class="language-ruby">factory :user do
  sequence(:email, 1000, aliases: [:sender, :receiver]) { |n| &quot;person#{n}@example.com&quot; }
end

# will increase value counter for :email which is shared by :sender and :receiver
generate(:sender)
</code></pre>
<p>Define aliases and use default value (1) for the counter</p>
<pre><code class="language-ruby">factory :user do
  sequence(:email, aliases: [:sender, :receiver]) { |n| &quot;person#{n}@example.com&quot; }
end
</code></pre>
<p>Setting the value:</p>
<pre><code class="language-ruby">factory :user do
  sequence(:email, 'a', aliases: [:sender, :receiver]) { |n| &quot;person#{n}@example.com&quot; }
end
</code></pre>
<p>The value needs to support the <code>#next</code> method. Here the next value will be 'a',
then 'b', etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-uris"><a class="header" href="#sequence-uris">Sequence URIs</a></h1>
<p>There are many reasons to manipulate a specific sequence:</p>
<ul>
<li>generating a single value with: <code>generate</code></li>
<li>generating multiple values with: <code>generate_list</code></li>
<li>setting it to a new value with <code>FactoryBot.set_sequence</code></li>
<li>rewinding it with: <code>rewind_sequence</code></li>
</ul>
<p>To accomplish this we need to be able to reference the desired sequence. This is achieved with its unique URI.</p>
<h2 id="uri-composition"><a class="header" href="#uri-composition">URI Composition</a></h2>
<p>Each URI is composed of up to three names:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">position</th><th>name</th><th>required</th></tr></thead><tbody>
<tr><td style="text-align: center">1.</td><td>factory name:</td><td><strong>if</strong> - the sequence is defined within a Factory or a Factory Trait</td></tr>
<tr><td style="text-align: center">2.</td><td>trait name:</td><td><strong>if</strong> - the sequence is defined within a Trait</td></tr>
<tr><td style="text-align: center">3.</td><td>sequence name:</td><td><strong>always required</strong></td></tr>
</tbody></table>
</div>
<p>The URI can be entered as individual symbols:</p>
<pre><code class="language-ruby">generate(:my_factory_name, :my_trait_name, :my_sequence_name)
</code></pre>
<p><strong>or</strong> as individual strings:</p>
<pre><code class="language-ruby">generate('my_factory_name', 'my_trait_name', 'my_sequence_name')
</code></pre>
<p><strong>or</strong> as a single resource string:</p>
<pre><code class="language-ruby">generate(&quot;my_factory_name/my_trait_name/my_sequence_name&quot;)
</code></pre>
<h2 id="full-uri-example"><a class="header" href="#full-uri-example">Full URI example</a></h2>
<p>This example details all the possible scenarios, with the comments showing the URI used to generate a value for each specific sequence:</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence(:sequence) {|n| &quot;global_sequence_#{n}&quot;}
  # generate(:sequence)

  trait :global_trait do
    sequence(:sequence) {|n| &quot;global_trait_sequence_#{n}&quot;}
    # generate(:global_trait, :sequence)
  end

  factory :user do
    sequence(:sequence) {|n| &quot;user_sequence_#{n}&quot;}
    # generate(:user, :sequence)

    trait :user_trait do
      sequence(:sequence) {|n| &quot;user_trait_sequence_#{n}&quot;}
      # generate(:user, :user_trait, :sequence)
    end

    factory :author do
      sequence(:sequence) {|n| &quot;author_sequence_#{n}&quot;}
      # generate(:author, :sequence)

      trait :author_trait do
        sequence(:sequence) {|n| &quot;author_trait_sequence_#{n}&quot;}
        # generate(:author, :author_trait, :sequence)
      end
    end
  end
end
</code></pre>
<h2 id="multi-uris"><a class="header" href="#multi-uris">Multi URIs</a></h2>
<p>It is possible for a single sequence to have multiple URIs.</p>
<p>If the factory or trait has aliases, the sequence will have an additional URI for each alias, or combination of aliases.</p>
<p>In this example, the same sequence can referenced in four different ways:</p>
<pre><code class="language-ruby">factory :user, aliases: [:author] do
  trait :user_trait, aliases: [:author_trait] do
    sequence(:sequence) {|n| &quot;author_trait_sequence_#{n}&quot;}
  end
end

# generate(:user,   :user_trait,   :sequence)
# generate(:user,   :author_trait, :sequence)
# generate(:author, :user_trait,   :sequence)
# generate(:author, :author_trait, :sequence)
</code></pre>
<div class='warning'>
<h2 id="important"><a class="header" href="#important">Important</a></h2>
<ul>
<li>
<p>No matter how deeply nested, the factory name component of the URI is always the factory where the sequence is defined, not any parent factories.</p>
</li>
<li>
<p>If a factory inherits a sequence, the URI must reference the factory where it was defined, not the one in which it is used.</p>
</li>
</ul>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rewinding"><a class="header" href="#rewinding">Rewinding</a></h1>
<p>Sequences can also be rewound to their starting value:</p>
<h2 id="all-sequences"><a class="header" href="#all-sequences">All sequences</a></h2>
<p>Rewind all global and factory sequences with <code>FactoryBot.rewind_sequences</code>:</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence(:email) {|n| &quot;person#{n}@example.com&quot; }

  factory :user do
    sequence(:email) {|n| &quot;user#{n}@example.com&quot; }
  end
end

generate(:email) # &quot;person1@example.com&quot;
generate(:email) # &quot;person2@example.com&quot;
generate(:email) # &quot;person3@example.com&quot;

generate(:user, :email) # &quot;user1@example.com&quot;
generate(:user, :email) # &quot;user2@example.com&quot;
generate(:user, :email) # &quot;user3@example.com&quot;

FactoryBot.rewind_sequences

generate(:email)        # &quot;person1@example.com&quot;
generate(:user, :email) # &quot;user1@example.com&quot;
</code></pre>
<h2 id="individual-sequences"><a class="header" href="#individual-sequences">Individual sequences</a></h2>
<p>An individual sequence can be rewound by passing the <a href="sequences/sequence-uris.html">sequence URI</a> to <code>FactoryBot.rewind_sequence</code>:</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence(:email) {|n| &quot;global_email_#{n}@example.com&quot; }

  factory :user do
    sequence(:email) {|n| &quot;user_email_#{n}@example.com&quot; }
  end
end

FactoryBot.rewind_sequence(:email)
generate(:email)
#=&gt; &quot;global_email_1@example.com&quot;

factoryBot.rewind_sequence(:user, :email)
generate(:user, :email)
#=&gt; &quot;user_email_1@example.com&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-the-value"><a class="header" href="#setting-the-value">Setting the value</a></h1>
<p>When testing or working in the console, being able to set the sequence to a specific value, is incredibly helpful. This can be achieved by passing the <a href="sequences/sequence-uris.html">sequence URI</a> and the new value to <code>FactoryBot.set_sequence</code>:</p>
<h2 id="global-sequences-2"><a class="header" href="#global-sequences-2">Global Sequences</a></h2>
<p>Global sequences are set with the sequence name and the new value:</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence(:char, 'a') {|c| &quot;global_character_#{c}&quot; }

  factory :user do
    sequence(:name, %w[Jane Joe Josh Jayde John].to_enum)

    trait :with_email do
      sequence(:email) {|n| &quot;user_#{n}@example.com&quot; }
    end
  end
end

##
# char
generate(:char) # &quot;global_character_a&quot;
FactoryBot.set_sequence(:char, 'z')
generate(:char) # &quot;global_character_z&quot;

##
# user name
generate(:user, :name) # &quot;Jane&quot;
FactoryBot.set_sequence(:user, :name, 'Jayde')
generate(:user, :name) # &quot;Jayde&quot;

##
# user email
generate(:user, :with_email, :email) # &quot;user_1@example.com&quot;
FactoryBot.set_sequence(:user, :with_email, :email, 1_234_567)
generate(:user, :with_email, :email) # &quot;user_1234567@example.com&quot;
</code></pre>
<div class='warning'>
<h2 id="note"><a class="header" href="#note">Note</a></h2>
<ul>
<li>
<p>The new value must match the sequence collection: You cannot pass a String to an Integer based sequence!</p>
</li>
<li>
<p>An integer based sequence, such as a record ID, can accept any positive integer as the value.</p>
</li>
<li>
<p>A fixed collection sequence can accept any value within the collection.</p>
</li>
<li>
<p>An unlimited sequence, such as a character <code>sequence(:unlimited,'a')</code> will timeout if not found within the default maximum search time of three seconds.</p>
</li>
<li>
<p>The timeout can be configured with: <code>FactoryBot.sequence_setting_timeout = 1.5</code></p>
</li>
</ul>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-a-sequence"><a class="header" href="#generating-a-sequence">Generating a Sequence</a></h1>
<p>Being able to directly generate a sequence, without having to build the object can really speed up testing. This can be achieved by passing the <a href="sequences/sequence-uris.html">sequence URI</a> to <code>:generate</code> for a single value or <code>:generate_list</code> for an Array of sequential values.</p>
<pre><code class="language-ruby">FactoryBot.define do
  sequence(:char, 'a') {|c| &quot;global_character_#{c}&quot; }

  factory :user do
    sequence(:name, %w[Jane Joe Josh Jayde John].to_enum)

    trait :with_age do
      sequence(:age, 21)
    end
  end
end

##
# char
generate(:char) # &quot;global_character_a&quot;
generate_list(:char, 2) # [&quot;global_character_b&quot;, &quot;global_character_c&quot;]
generate(:char) # &quot;global_character_d&quot;

##
# user name
generate(:user, :name) # &quot;Jane&quot;
generate_list(:user, :name, 3) # ['Joe', 'Josh', 'Jayde']
generate(:user, :name) # &quot;John&quot;

##
# user age
generate(:user, :with_age, :age) # 21
generate_list(:user, :with_age, :age, 5) # [22, 23, 24, 25, 26]
generate(:user, :with_age, :age) # 27
</code></pre>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>On occasion a sequence block may refer to a scoped attribute. In this case, the scope must be provided, or else an exception will be raised:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :user do
    sequence(:email) { |n| &quot;#{name}-#{n}@example.com&quot; }
  end
end

generate(:user, :email)
# ArgumentError, Sequence user:email failed to return a value. Perhaps it needs a scope to operate? (scope: &lt;object&gt;)

jester = build(:user, name: &quot;Jester&quot;)
jester.email # &quot;Jester-1@example.com&quot;

generate(:user, :email, scope: jester)
# &quot;Jester-2@example.com&quot;

generate_list(:user, :email, 2, scope: jester)
# [&quot;Jester-3@example.com&quot;, &quot;Jester-4@example.com&quot;]
</code></pre>
<p>When testing, the scope can be any object that responds to the referenced attributes:</p>
<pre><code class="language-ruby">require 'ostruct'

FactoryBot.define
  factory :user do
    sequence(:info) { |n| &quot;#{name}-#{n}-#{age + n}&quot; }
  end
end

test_scope = OpenStruct.new(name: &quot;Jester&quot;, age: 23)

generate_list('user/info', 3, scope: test_scope)
# [&quot;Jester-1-24&quot;, &quot;Jester-2-25&quot;, &quot;Jester-3-26&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uniqueness"><a class="header" href="#uniqueness">Uniqueness</a></h1>
<p>When working with uniqueness constraints, be careful not to pass in override
values that will conflict with the generated sequence values.</p>
<p>In this example the email will be the same for both users. If email must be
unique, this code will error:</p>
<pre><code class="language-rb">factory :user do
  sequence(:email) { |n| &quot;person#{n}@example.com&quot; }
end

FactoryBot.create(:user, email: &quot;person1@example.com&quot;)
FactoryBot.create(:user)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Traits allow you to group attributes together and then apply them
to any factory.</p>
<pre><code class="language-ruby">factory :user, aliases: [:author]

factory :story do
  title { &quot;My awesome story&quot; }
  author

  trait :published do
    published { true }
  end

  trait :unpublished do
    published { false }
  end

  trait :week_long_publishing do
    start_at { 1.week.ago }
    end_at { Time.now }
  end

  trait :month_long_publishing do
    start_at { 1.month.ago }
    end_at { Time.now }
  end

  factory :week_long_published_story,    traits: [:published, :week_long_publishing]
  factory :month_long_published_story,   traits: [:published, :month_long_publishing]
  factory :week_long_unpublished_story,  traits: [:unpublished, :week_long_publishing]
  factory :month_long_unpublished_story, traits: [:unpublished, :month_long_publishing]
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-implicit-attributes-1"><a class="header" href="#as-implicit-attributes-1">As implicit attributes</a></h1>
<p>Traits can be used as implicit attributes:</p>
<pre><code class="language-ruby">factory :week_long_published_story_with_title, parent: :story do
  published
  week_long_publishing
  title { &quot;Publishing that was started at #{start_at}&quot; }
end
</code></pre>
<p>Note that defining traits as implicit attributes will not work if you have a
factory or sequence with the same name as the trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-traits"><a class="header" href="#using-traits">Using traits</a></h1>
<p>Traits can also be passed in as a list of Symbols when you construct an instance
from factory_bot.</p>
<pre><code class="language-ruby">factory :user do
  name { &quot;Friendly User&quot; }

  trait :active do
    name { &quot;John Doe&quot; }
    status { :active }
  end

  trait :admin do
    admin { true }
  end
end

# creates an admin user with :active status and name &quot;Jon Snow&quot;
create(:user, :admin, :active, name: &quot;Jon Snow&quot;)
</code></pre>
<p>This ability works with <code>build</code>, <code>build_stubbed</code>, <code>attributes_for</code>, and <code>create</code>.</p>
<p><code>create_list</code> and <code>build_list</code> methods are supported as well. Remember to pass
the number of instances to create/build as second parameter, as documented in
the &quot;Building or Creating Multiple Records&quot; section of this file.</p>
<pre><code class="language-ruby">factory :user do
  name { &quot;Friendly User&quot; }

  trait :active do
    name { &quot;John Doe&quot; }
    status { :active }
  end

  trait :admin do
    admin { true }
  end
end

# creates 3 admin users with :active status and name &quot;Jon Snow&quot;
create_list(:user, 3, :admin, :active, name: &quot;Jon Snow&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-traits"><a class="header" href="#enum-traits">Enum traits</a></h1>
<p>Given an Active Record model with an enum attribute:</p>
<pre><code class="language-rb">class Task &lt; ActiveRecord::Base
  enum status: {queued: 0, started: 1, finished: 2}
end

</code></pre>
<p>factory_bot will automatically define traits for each possible value of the
enum:</p>
<pre><code class="language-rb">FactoryBot.define do
  factory :task
end

FactoryBot.build(:task, :queued)
FactoryBot.build(:task, :started)
FactoryBot.build(:task, :finished)
</code></pre>
<p>Writing the traits out manually would be cumbersome, and is not necessary:</p>
<pre><code class="language-rb">FactoryBot.define do
  factory :task do
    trait :queued do
      status { :queued }
    end

    trait :started do
      status { :started }
    end

    trait :finished do
      status { :finished }
    end
  end
end
</code></pre>
<p>If automatically defining traits for enum attributes on every factory is not
desired, it is possible to disable the feature by setting
<code>FactoryBot.automatically_define_enum_traits = false</code></p>
<p>In that case, it is still possible to explicitly define traits for an enum
attribute in a particular factory:</p>
<pre><code class="language-rb">FactoryBot.automatically_define_enum_traits = false

FactoryBot.define do
  factory :task do
    traits_for_enum(:status)
  end
end
</code></pre>
<p>It is also possible to use this feature for other enumerable values, not
specifically tied to Active Record enum attributes.</p>
<p>With an array:</p>
<pre><code class="language-rb">class Task
  attr_accessor :status
end

FactoryBot.define do
  factory :task do
    traits_for_enum(:status, [&quot;queued&quot;, &quot;started&quot;, &quot;finished&quot;])
  end
end
</code></pre>
<p>Or with a hash:</p>
<pre><code class="language-rb">class Task
  attr_accessor :status
end

FactoryBot.define do
  factory :task do
    traits_for_enum(:status, { queued: 0, started: 1, finished: 2 })
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attribute-precedence"><a class="header" href="#attribute-precedence">Attribute precedence</a></h1>
<p>Traits that define the same attributes won't raise AttributeDefinitionErrors;
the trait that defines the attribute last gets precedence.</p>
<pre><code class="language-ruby">factory :user do
  name { &quot;Friendly User&quot; }
  login { name }

  trait :active do
    name { &quot;John Doe&quot; }
    status { :active }
    login { &quot;#{name} (active)&quot; }
  end

  trait :inactive do
    name { &quot;Jane Doe&quot; }
    status { :inactive }
    login { &quot;#{name} (inactive)&quot; }
  end

  trait :admin do
    admin { true }
    login { &quot;admin-#{name}&quot; }
  end

  factory :active_admin,   traits: [:active, :admin]   # login will be &quot;admin-John Doe&quot;
  factory :inactive_admin, traits: [:admin, :inactive] # login will be &quot;Jane Doe (inactive)&quot;
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-child-factories"><a class="header" href="#in-child-factories">In child factories</a></h1>
<p>You can override individual attributes granted by a trait in a child factory:</p>
<pre><code class="language-ruby">factory :user do
  name { &quot;Friendly User&quot; }
  login { name }

  trait :active do
    name { &quot;John Doe&quot; }
    status { :active }
    login { &quot;#{name} (M)&quot; }
  end

  factory :brandon do
    active
    name { &quot;Brandon&quot; }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-mixins"><a class="header" href="#as-mixins">As mixins</a></h1>
<p>Traits can be defined outside of factories and used as mixins to compose shared
attributes:</p>
<pre><code class="language-ruby">FactoryBot.define do
  trait :timestamps do
    created_at { 8.days.ago }
    updated_at { 4.days.ago }
  end
  
  factory :user, traits: [:timestamps] do
    username { &quot;john_doe&quot; }
  end
  
  factory :post do
    timestamps
    title { &quot;Traits rock&quot; }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-associations-1"><a class="header" href="#with-associations-1">With associations</a></h1>
<p>Traits can be used with associations easily too:</p>
<pre><code class="language-ruby">factory :user do
  name { &quot;Friendly User&quot; }

  trait :admin do
    admin { true }
  end
end

factory :post do
  association :user, :admin, name: 'John Doe'
end

# creates an admin user with name &quot;John Doe&quot;
create(:post).user
</code></pre>
<p>When you're using association names that are different than the factory:</p>
<pre><code class="language-ruby">factory :user do
  name { &quot;Friendly User&quot; }

  trait :admin do
    admin { true }
  end
end

factory :post do
  association :author, :admin, factory: :user, name: 'John Doe'
  # or
  association :author, factory: [:user, :admin], name: 'John Doe'
end

# creates an admin user with name &quot;John Doe&quot;
create(:post).author
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-within-traits"><a class="header" href="#traits-within-traits">Traits within traits</a></h1>
<p>Traits can be used within other traits to mix in their attributes.</p>
<pre><code class="language-ruby">factory :order do
  trait :completed do
    completed_at { 3.days.ago }
  end

  trait :refunded do
    completed
    refunded_at { 1.day.ago }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-transient-attributes"><a class="header" href="#with-transient-attributes">With transient attributes</a></h1>
<p>Traits can accept transient attributes.</p>
<pre><code class="language-ruby">factory :invoice do
  trait :with_amount do
    transient do
      amount { 1 }
    end

    after(:create) do |invoice, context|
      create :line_item, invoice: invoice, amount: context.amount
    end
  end
end

create :invoice, :with_amount, amount: 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<p>factory_bot makes six callbacks available:</p>
<div class="table-wrapper"><table><thead><tr><th>Callback</th><th>Timing</th></tr></thead><tbody>
<tr><td>before(:all)</td><td>called before any strategy is used to construct an object, including custom strategies</td></tr>
<tr><td>before(:build)</td><td>called before a factory builds an object (via <code>FactoryBot.build</code> or <code>FactoryBot.create</code>)</td></tr>
<tr><td>after(:build)</td><td>called after a factory builds an object (via <code>FactoryBot.build</code> or <code>FactoryBot.create</code>)</td></tr>
<tr><td>before(:create)</td><td>called before a factory saves an object (via <code>FactoryBot.create</code>)</td></tr>
<tr><td>after(:create)</td><td>called after a factory saves an object (via <code>FactoryBot.create</code>)</td></tr>
<tr><td>after(:stub)</td><td>called after a factory stubs an object (via <code>FactoryBot.build_stubbed</code>)</td></tr>
<tr><td>after(:all)</td><td>called after any strategy has completed, including custom strategies</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="calling-an-objects-own-method-after-building"><a class="header" href="#calling-an-objects-own-method-after-building">Calling an object's own method after building</a></h3>
<pre><code class="language-ruby">##
# Define a factory that calls the generate_hashed_password method
# after the user factory is built.
#
# Note that you'll have an instance of the object in the block
#
factory :user do
  after(:build) { |user, context| generate_hashed_password(user) }
end
</code></pre>
<h3 id="skipping-an-objects-own-after_create-callback"><a class="header" href="#skipping-an-objects-own-after_create-callback">Skipping an object's own :after_create callback</a></h3>
<pre><code class="language-ruby">##
# Disable a model's own :after_create callback that sends an email
# on creation, then re-enable it afterwards
#
factory :user do
  before(:all){ User.skip_callback(:create, :after, :send_welcome_email) }
  after(:all){ User.set_callback(:create, :after, :send_welcome_email) }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-callbacks"><a class="header" href="#multiple-callbacks">Multiple callbacks</a></h1>
<p>You can also define multiple types of callbacks on the same factory:</p>
<pre><code class="language-ruby">factory :user do
  after(:build)  { |user| do_something_to(user) }
  after(:create) { |user| do_something_else_to(user) }
end
</code></pre>
<p>Factories can also define any number of the same kind of callback.  These
callbacks will be executed in the order they are specified:</p>
<pre><code class="language-ruby">factory :user do
  after(:create) { this_runs_first }
  after(:create) { then_this }
end
</code></pre>
<p>Calling <code>create</code> will invoke both <code>after_build</code> and <code>after_create</code> callbacks.</p>
<p>Also, like standard attributes, child factories will inherit (and can also
define) callbacks from their parent factory.</p>
<p>Multiple callbacks can be assigned to run a block; this is useful when building
various strategies that run the same code (since there are no callbacks that are
shared across all strategies).</p>
<pre><code class="language-ruby">factory :user do
  callback(:after_stub, :before_create) { do_something }
  after(:stub, :create) { do_something_else }
  before(:create, :custom) { do_a_third_thing }
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-callbacks"><a class="header" href="#global-callbacks">Global callbacks</a></h1>
<p>To override callbacks for all factories, define them within the
<code>FactoryBot.define</code> block:</p>
<pre><code class="language-ruby">FactoryBot.define do
  after(:build) { |object| puts &quot;Built #{object}&quot; }
  after(:create) { |object| AuditLog.create(attrs: object.attributes) }

  factory :user do
    name { &quot;John Doe&quot; }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbolto_proc"><a class="header" href="#symbolto_proc">Symbol#to_proc</a></h1>
<p>You can call callbacks that rely on <code>Symbol#to_proc</code>:</p>
<pre><code class="language-ruby"># app/models/user.rb
class User &lt; ActiveRecord::Base
  def confirm!
    # confirm the user account
  end
end

# spec/factories.rb
FactoryBot.define do
  factory :user do
    after :create, &amp;:confirm!
  end
end

create(:user) # creates the user and confirms it
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callback-order"><a class="header" href="#callback-order">Callback Order</a></h1>
<p>When a callback event like <code>after_build</code> or <code>before_all</code> is triggered, all callbacks for that event are executed in the following order:</p>
<ol>
<li>Global callbacks.</li>
<li>Inherited callbacks.</li>
<li>Factory callbacks.</li>
<li>Trait callbacks (in the order requested).</li>
</ol>
<h2 id="a-simple-factory-example"><a class="header" href="#a-simple-factory-example">A simple factory example:</a></h2>
<pre><code class="language-ruby">FactoryBot.define do
  before(:all) { puts &quot;Global before(:all)&quot; }
  after(:all) { puts &quot;Global after(:all)&quot; }

  factory :user do
    before(:all) { puts &quot;User before(:all)&quot; }
    after(:all) { puts &quot;User after(:all)&quot; }
    before(:build) { puts &quot;User before(:build)&quot; }
    after(:build) { puts &quot;User after(:build)&quot; }

    trait :trait_a do
      before(:build) { puts &quot;Trait-A before(:build)&quot; }
      after(:build) { puts &quot;Trait-A after(:build)&quot; }
    end

    trait :trait_b do
      before(:build) { puts &quot;Trait-B before(:build)&quot; }
      after(:build) { puts &quot;Trait-B after(:build)&quot; }
    end
  end
end

build(:user, :trait_b, :trait_a)

# Result:
#
# 1. &quot;Global before(:all)&quot;
# 2. &quot;User before(:all)&quot;
# 3. &quot;User before(:build)
# 4. &quot;Trait-B before(:build)&quot;
# 5. &quot;Trait-A before(:build)&quot;
# 6. &quot;User after(:build)&quot;
# 7. &quot;Trait-B after(:build)&quot;
# 8. &quot;Trait-A after(:build)&quot;
# 9. &quot;Global after(:all)&quot;
# 10. &quot;User after(:all)&quot;

</code></pre>
<h2 id="an-inherited-factory-example"><a class="header" href="#an-inherited-factory-example">An inherited factory example:</a></h2>
<pre><code class="language-ruby">FactoryBot.define do
  before(:all) { puts &quot;Global before(:all)&quot; }
  before(:build) { puts &quot;Global before(:build)&quot; }
  after(:build) { puts &quot;Global after(:build)&quot; }
  after(:all) { puts &quot;Global after(:all)&quot; }

  factory :parent do
    before(:all) { puts &quot;Parent before(:all)&quot; }
    before(:build) { puts &quot;Parent before(:build)&quot; }
    after(:all) { puts &quot;Parent after(:all)&quot; }
    after(:build) { puts &quot;Parent after(:build)&quot; }

    trait :trait_a do
      before(:build) { puts &quot;Trait-A before(:build)&quot; }
      after(:build) { puts &quot;Trait-A after(:build)&quot; }
    end

    factory :child do
      before(:all) { puts &quot;Child before(:all)&quot; }
      before(:build) { puts &quot;Child before(:build)&quot; }
      after(:build) { puts &quot;Child after(:build)&quot; }
      after(:all) { puts &quot;Child after(:all)&quot; }

      trait :trait_b do
        before(:build) { puts &quot;Trait-B before(:build)&quot; }
        after(:build) { puts &quot;Trait-B after(:build)&quot; }
        after(:all) { puts &quot;Trait-B after(:all)&quot; }
      end

      trait :trait_c do
        before(:build) { puts &quot;Trait-C before(:build)&quot; }
        after(:build) { puts &quot;Trait-C after(:build)&quot; }
        before(:all) { puts &quot;Trait-C before(:all)&quot; }
      end
    end
  end
end

build(:child, :trait_c, :trait_a, :trait_b)

# Result:
#
# 1. &quot;Global before(:all)&quot;
# 2. &quot;Parent before(:all)&quot;
# 3. &quot;Child before(:all)&quot;
# 4. &quot;Trait-C before(:all)&quot;
# 5. &quot;Global before(:build)&quot;
# 6. &quot;Parent before(:build)&quot;
# 7. &quot;Child before(:build)&quot;
# 8. &quot;Trait-C before(:build)&quot;
# 9. &quot;Trait-A before(:build)&quot;
# 10. &quot;Trait-B before(:build)&quot;
# 11. &quot;Global after(:build)&quot;
# 12. &quot;Parent after(:build)&quot;
# 13. &quot;Child after(:build)&quot;
# 14. &quot;Trait-C after(:build)&quot;
# 15. &quot;Trait-A after(:build)&quot;
# 16. &quot;Trait-B after(:build)&quot;
# 17. &quot;Global after(:all)&quot;
# 18. &quot;Parent after(:all)&quot;
# 19. &quot;Child after(:all)&quot;
# 20. &quot;Trait-B after(:all)&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifying-factories"><a class="header" href="#modifying-factories">Modifying factories</a></h1>
<p>If you're given a set of factories (say, from a gem developer) but want to
change them to fit into your application better, you can modify that factory
instead of creating a child factory and adding attributes there.</p>
<p>If a gem were to give you a User factory:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :user do
    full_name { &quot;John Doe&quot; }
    sequence(:username) { |n| &quot;user#{n}&quot; }
    password { &quot;password&quot; }
  end
end
</code></pre>
<p>Instead of creating a child factory that added additional attributes:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :application_user, parent: :user do
    full_name { &quot;Jane Doe&quot; }
    date_of_birth { 21.years.ago }
    health { 90 }
  end
end
</code></pre>
<p>You could modify that factory instead.</p>
<pre><code class="language-ruby">FactoryBot.modify do
  factory :user do
    full_name { &quot;Jane Doe&quot; }
    date_of_birth { 21.years.ago }
    health { 90 }
  end
end
</code></pre>
<p>When modifying a factory, you can change any of the attributes you want (aside from callbacks).</p>
<p><code>FactoryBot.modify</code> must be called outside of a <code>FactoryBot.define</code> block as it
operates on factories differently.</p>
<p>A caveat: you can only modify factories (not sequences or traits), and
callbacks <em>still compound as they normally would</em>. So, if the factory you're
modifying defines an <code>after(:create)</code> callback, you defining an
<code>after(:create)</code> won't override it, it will instead be run after the first
callback.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linting-factories"><a class="header" href="#linting-factories">Linting Factories</a></h1>
<p>factory_bot allows for linting known factories:</p>
<pre><code class="language-ruby">FactoryBot.lint
</code></pre>
<p><code>FactoryBot.lint</code> creates each factory and catches any exceptions raised during
the creation process. <code>FactoryBot::InvalidFactoryError</code> is raised with a list
of factories (and corresponding exceptions) for factories which could not be
created.</p>
<p>Recommended usage of <code>FactoryBot.lint</code> is to run this in a separate task before
your test suite is executed. Running it in a <code>before(:suite)</code> will negatively
impact the performance of your tests when running single tests.</p>
<p>Example Rake task:</p>
<pre><code class="language-ruby"># lib/tasks/factory_bot.rake
namespace :factory_bot do
  desc &quot;Verify that all FactoryBot factories are valid&quot;
  task lint: :environment do
    if Rails.env.test?
      conn = ActiveRecord::Base.connection
      conn.transaction do
        FactoryBot.lint
        raise ActiveRecord::Rollback
      end
    else
      system(&quot;bundle exec rake factory_bot:lint RAILS_ENV='test'&quot;)
      fail if $?.exitstatus.nonzero?
    end
  end
end
</code></pre>
<p>After calling <code>FactoryBot.lint</code>, you'll likely want to clear out the database,
as records will most likely be created. The provided example above uses an SQL
transaction and rollback to leave the database clean.</p>
<p>You can lint factories selectively by passing only factories you want linted:</p>
<pre><code class="language-ruby">factories_to_lint = FactoryBot.factories.reject do |factory|
  factory.name =~ /^old_/
end

FactoryBot.lint factories_to_lint
</code></pre>
<p>This would lint all factories that aren't prefixed with <code>old_</code>.</p>
<p>Traits can also be linted. This option verifies that each and every trait of a
factory generates a valid object on its own. This is turned on by passing
<code>traits: true</code> to the <code>lint</code> method:</p>
<pre><code class="language-ruby">FactoryBot.lint traits: true
</code></pre>
<p>This can also be combined with other arguments:</p>
<pre><code class="language-ruby">FactoryBot.lint factories_to_lint, traits: true
</code></pre>
<p>You can also specify the strategy used for linting:</p>
<pre><code class="language-ruby">FactoryBot.lint strategy: :build
</code></pre>
<p>Verbose linting will include full backtraces for each error, which can be
helpful for debugging:</p>
<pre><code class="language-ruby">FactoryBot.lint verbose: true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-construction"><a class="header" href="#custom-construction">Custom Construction</a></h1>
<p>If you want to use factory_bot to construct an object where some attributes
are passed to <code>initialize</code> or if you want to do something other than simply
calling <code>new</code> on your build class, you can override the default behavior by
defining <code>initialize_with</code> on your factory. Example:</p>
<pre><code class="language-ruby"># user.rb
class User
  attr_accessor :name, :email

  def initialize(name)
    @name = name
  end
end

# factories.rb
sequence(:email) { |n| &quot;person#{n}@example.com&quot; }

factory :user do
  name { &quot;Jane Doe&quot; }
  email

  initialize_with { new(name) }
end

build(:user).name # Jane Doe
</code></pre>
<p>Although factory_bot is written to work with ActiveRecord out of the box, it
can also work with any Ruby class. For maximum compatibility with ActiveRecord,
the default initializer builds all instances by calling <code>new</code> on your build
class without any arguments. It then calls attribute writer methods to assign
all the attribute values. While that works fine for ActiveRecord, it actually
doesn't work for almost any other Ruby class.</p>
<p>You can override the initializer in order to:</p>
<ul>
<li>Build non-ActiveRecord objects that require arguments to <code>initialize</code></li>
<li>Use a method other than <code>new</code> to instantiate the instance</li>
<li>Do wild things like decorate the instance after it's built</li>
</ul>
<p>When using <code>initialize_with</code>, you don't have to declare the class itself when
calling <code>new</code>; however, any other class methods you want to call will have to
be called on the class explicitly.</p>
<p>For example:</p>
<pre><code class="language-ruby">factory :user do
  name { &quot;John Doe&quot; }

  initialize_with { User.build_with_name(name) }
end
</code></pre>
<p>You can also access all public attributes within the <code>initialize_with</code> block
by calling <code>attributes</code>:</p>
<pre><code class="language-ruby">factory :user do
  transient do
    comments_count { 5 }
  end

  name &quot;John Doe&quot;

  initialize_with { new(**attributes) }
end
</code></pre>
<p>This will build a hash of all attributes to be passed to <code>new</code>. It won't
include transient attributes, but everything else defined in the factory will
be passed (associations, evaluated sequences, etc.)</p>
<p>You can define <code>initialize_with</code> for all factories by including it in the
<code>FactoryBot.define</code> block:</p>
<pre><code class="language-ruby">FactoryBot.define do
  initialize_with { new(&quot;Awesome first argument&quot;) }
end
</code></pre>
<p>When using <code>initialize_with</code>, attributes accessed from within the
<code>initialize_with</code> block are assigned <em>only</em> in the constructor; this equates to
roughly the following code:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :user do
    initialize_with { new(name) }

    name { 'value' }
  end
end

build(:user)
# runs
User.new('value')
</code></pre>
<p>This prevents duplicate assignment; in versions of factory_bot before 4.0, it
would run this:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :user do
    initialize_with { new(name) }

    name { 'value' }
  end
end

build(:user)
# runs
user = User.new('value')
user.name = 'value'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-strategies"><a class="header" href="#custom-strategies">Custom Strategies</a></h1>
<p>There are times where you may want to extend behavior of factory_bot by adding
a custom build strategy.</p>
<p>Strategies define two methods: <code>association</code> and <code>result</code>. <code>association</code>
receives a <code>FactoryBot::FactoryRunner</code> instance, upon which you can call <code>run</code>,
overriding the strategy if you want. The second method, <code>result</code>, receives a
<code>FactoryBot::Evaluation</code> instance. It provides a way to trigger callbacks (with
<code>notify</code>), <code>object</code> or <code>hash</code> (to get the result instance or a hash based on
the attributes defined in the factory), and <code>create</code>, which executes the
<code>to_create</code> callback defined on the factory.</p>
<p>To understand how factory_bot uses strategies internally, it's probably
easiest to view the source for each of the four default strategies.</p>
<p>Here's an example of composing a strategy using <code>FactoryBot::Strategy::Create</code>
to build a JSON representation of your model.</p>
<pre><code class="language-ruby">class JsonStrategy
  def initialize
    @strategy = FactoryBot.strategy_by_name(:create).new
  end

  delegate :association, to: :@strategy

  def result(evaluation)
    @strategy.result(evaluation).to_json
  end

  def to_sym
    :json
  end
end
</code></pre>
<p>For factory_bot to recognize the new strategy, you can register it:</p>
<pre><code class="language-ruby">FactoryBot.register_strategy(:json, JsonStrategy)
</code></pre>
<p>This allows you to call</p>
<pre><code class="language-ruby">FactoryBot.json(:user)
</code></pre>
<p>Finally, you can override factory_bot's own strategies if you'd like by
registering a new object in place of the strategies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-callbacks"><a class="header" href="#custom-callbacks">Custom Callbacks</a></h1>
<p>Custom callbacks can be defined if you're using custom strategies:</p>
<pre><code class="language-ruby">class JsonStrategy
  def initialize
    @strategy = FactoryBot.strategy_by_name(:create).new
  end

  delegate :association, to: :@strategy

  def result(evaluation)
    result = @strategy.result(evaluation)
    evaluation.notify(:before_json, result)

    result.to_json.tap do |json|
      evaluation.notify(:after_json, json)
      evaluation.notify(:make_json_awesome, json)
    end
  end

  def to_sym
    :json
  end
end

FactoryBot.register_strategy(:json, JsonStrategy)

FactoryBot.define do
  factory :user do
    before(:json)                { |user| do_something_to(user) }
    after(:json)                 { |user_json| do_something_to(user_json) }
    callback(:make_json_awesome) { |user_json| do_something_to(user_json) }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-methods-to-persist-objects"><a class="header" href="#custom-methods-to-persist-objects">Custom Methods to Persist Objects</a></h1>
<p>By default, creating a record will call <code>save!</code> on the instance; since this may
not always be ideal, you can override that behavior by defining <code>to_create</code> on
the factory:</p>
<pre><code class="language-ruby">factory :different_orm_model do
  to_create { |instance| instance.persist! }
end
</code></pre>
<p>To disable the persistence method altogether on create, you can <code>skip_create</code>
for that factory:</p>
<pre><code class="language-ruby">factory :user_without_database do
  skip_create
end
</code></pre>
<p>To override <code>to_create</code> for all factories, define it within the
<code>FactoryBot.define</code> block:</p>
<pre><code class="language-ruby">FactoryBot.define do
  to_create { |instance| instance.persist! }


  factory :user do
    name { &quot;John Doe&quot; }
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="activesupport-instrumentation"><a class="header" href="#activesupport-instrumentation">ActiveSupport Instrumentation</a></h1>
<p>In order to track what factories are created (and with what build strategy),
<code>ActiveSupport::Notifications</code> are included to provide a way to subscribe to
factories being compiled and run. One example would be to track factories based on a
threshold of execution time.</p>
<pre><code class="language-ruby">ActiveSupport::Notifications.subscribe(&quot;factory_bot.run_factory&quot;) do |name, start, finish, id, payload|
  execution_time_in_seconds = finish - start

  if execution_time_in_seconds &gt;= 0.5
    $stderr.puts &quot;Slow factory: #{payload[:name]} using strategy #{payload[:strategy]}&quot;
  end
end
</code></pre>
<p>Another example would be tracking all factories and how they're used throughout
your test suite. If you're using RSpec, it's as simple as adding a
<code>before(:suite)</code> and <code>after(:suite)</code>:</p>
<pre><code class="language-ruby">factory_bot_results = {}
config.before(:suite) do
  ActiveSupport::Notifications.subscribe(&quot;factory_bot.run_factory&quot;) do |name, start, finish, id, payload|
    factory_name = payload[:name]
    strategy_name = payload[:strategy]
    factory_bot_results[factory_name] ||= {}
    factory_bot_results[factory_name][strategy_name] ||= 0
    factory_bot_results[factory_name][strategy_name] += 1
  end
end

config.after(:suite) do
  puts factory_bot_results
end
</code></pre>
<p>Another example could involve tracking the attributes and traits that factories are compiled with. If you're using RSpec, you could add <code>before(:suite)</code> and <code>after(:suite)</code> blocks that subscribe to <code>factory_bot.compile_factory</code> notifications:</p>
<pre><code class="language-ruby">factory_bot_results = {}
config.before(:suite) do
  ActiveSupport::Notifications.subscribe(&quot;factory_bot.compile_factory&quot;) do |name, start, finish, id, payload|
    factory_name = payload[:name]
    factory_class = payload[:class]
    attributes = payload[:attributes]
    traits = payload[:traits]
    factory_bot_results[factory_class] ||= {}
    factory_bot_results[factory_class][factory_name] = {
      attributes: attributes.map(&amp;:name)
      traits: traits.map(&amp;:name)
    }
  end
end

config.after(:suite) do
  puts factory_bot_results
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="has_many-associations"><a class="header" href="#has_many-associations">has_many associations</a></h1>
<p>There are a few ways to generate data for a <code>has_many</code> relationship. The
simplest approach is to write a helper method in plain Ruby to tie together the
different records:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :post do
    title { &quot;Through the Looking Glass&quot; }
    user
  end

  factory :user do
    name { &quot;Rachel Sanchez&quot; }
  end
end

def user_with_posts(posts_count: 5)
  FactoryBot.create(:user) do |user|
    FactoryBot.create_list(:post, posts_count, user: user)
  end
end

create(:user).posts.length # 0
user_with_posts.posts.length # 5
user_with_posts(posts_count: 15).posts.length # 15
</code></pre>
<p>If you prefer to keep the object creation fully within factory_bot, you can
build the posts in an <code>after(:create)</code> callback.</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :post do
    title { &quot;Through the Looking Glass&quot; }
    user
  end

  factory :user do
    name { &quot;John Doe&quot; }

    # user_with_posts will create post data after the user has been created
    factory :user_with_posts do
      # posts_count is declared as a transient attribute available in the
      # callback via the context
      transient do
        posts_count { 5 }
      end

      # the after(:create) yields two values; the user instance itself and the
      # context, which stores all values from the factory, including transient
      # attributes; `create_list`'s second argument is the number of records
      # to create and we make sure the user is associated properly to the post
      after(:create) do |user, context|
        create_list(:post, context.posts_count, user: user)

        # You may need to reload the record here, depending on your application
        user.reload
      end
    end
  end
end

create(:user).posts.length # 0
create(:user_with_posts).posts.length # 5
create(:user_with_posts, posts_count: 15).posts.length # 15
</code></pre>
<p>The following is a simple example that works without having to save to the
database. It works with <code>build</code>, <code>build_stubbed</code>, and <code>create</code> (although it
doesn't work well with <code>attributes_for</code>), you can use inline associations:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :post do
    title { &quot;Through the Looking Glass&quot; }
    user
  end

  factory :user do
    name { &quot;Taylor Kim&quot; }

    factory :user_with_posts do
      posts { [association(:post)] }
    end

    # or

    trait :with_posts do
      posts { [association(:post)] }
    end
  end
end

create(:user).posts.length # 0
create(:user_with_posts).posts.length # 1
build(:user_with_posts).posts.length # 1
build_stubbed(:user_with_posts).posts.length # 1
</code></pre>
<p>For more flexibility you can combine this with the <code>posts_count</code> transient
attribute from the callback example:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :post do
    title { &quot;Through the Looking Glass&quot; }
    user
  end

  factory :user do
    name { &quot;Adiza Kumato&quot; }

    factory :user_with_posts do
      transient do
        posts_count { 5 }
      end

      posts do
        Array.new(posts_count) { association(:post) }
      end
    end
  end
end

create(:user_with_posts).posts.length # 5
create(:user_with_posts, posts_count: 15).posts.length # 15
build(:user_with_posts, posts_count: 15).posts.length # 15
build_stubbed(:user_with_posts, posts_count: 15).posts.length # 15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="has_and_belongs_to_many-associations"><a class="header" href="#has_and_belongs_to_many-associations">has_and_belongs_to_many associations</a></h1>
<p>Generating data for a <code>has_and_belongs_to_many</code> relationship is very similar
to the above <code>has_many</code> relationship, with a small change: you need to pass an
array of objects to the model's pluralized attribute name rather than a single
object to the singular version of the attribute name.</p>
<pre><code class="language-ruby">def profile_with_languages(languages_count: 2)
  FactoryBot.create(:profile) do |profile|
    FactoryBot.create_list(:language, languages_count, profiles: [profile])
  end
end
</code></pre>
<p>Or with the callback approach:</p>
<pre><code class="language-ruby">factory :profile_with_languages do
  transient do
    languages_count { 2 }
  end

  after(:create) do |profile, context|
    create_list(:language, context.languages_count, profiles: [profile])
    profile.reload
  end
end
</code></pre>
<p>Or the inline association approach (note the use of the <code>instance</code> method here
to refer to the profile being built):</p>
<pre><code class="language-ruby">factory :profile_with_languages do
  transient do
    languages_count { 2 }
  end

  languages do
    Array.new(languages_count) do
      association(:language, profiles: [instance])
    end
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphic-associations"><a class="header" href="#polymorphic-associations">Polymorphic associations</a></h1>
<p>Polymorphic associations can be handled with traits:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :video
  factory :photo

  factory :comment do
    for_photo # default to the :for_photo trait if none is specified

    trait :for_video do
      association :commentable, factory: :video
    end

    trait :for_photo do
      association :commentable, factory: :photo
    end
  end
end
</code></pre>
<p>This allows us to do:</p>
<pre><code class="language-ruby">create(:comment)
create(:comment, :for_video)
create(:comment, :for_photo)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interconnected-associations"><a class="header" href="#interconnected-associations">Interconnected associations</a></h1>
<p>There are limitless ways objects might be interconnected, and
factory_bot may not always be suited to handle those relationships. In some
cases it makes sense to use factory_bot to build each individual object, and
then to write helper methods in plain Ruby to tie those objects together.</p>
<p>That said, some more complex, interconnected relationships can be built in factory_bot
using inline associations with reference to the <code>instance</code> being built.</p>
<p>Let's say your models look like this, where an associated <code>Student</code> and
<code>Profile</code> should both belong to the same <code>School</code>:</p>
<pre><code class="language-ruby">class Student &lt; ApplicationRecord
  belongs_to :school
  has_one :profile
end

class Profile &lt; ApplicationRecord
  belongs_to :school
  belongs_to :student
end

class School &lt; ApplicationRecord
  has_many :students
  has_many :profiles
end
</code></pre>
<p>We can ensure the student and profile are connected to each other and to the
same school with a factory like this:</p>
<pre><code class="language-ruby">FactoryBot.define do
  factory :student do
    school
    profile { association :profile, student: instance, school: school }
  end

  factory :profile do
    school
    student { association :student, profile: instance, school: school }
  end

  factory :school
end
</code></pre>
<p>Note that this approach works with <code>build</code>, <code>build_stubbed</code>, and <code>create</code>, but
the associations will return <code>nil</code> when using <code>attributes_for</code>.</p>
<p>Also, note that if you assign any attributes inside a custom <code>initialize_with</code> 
(e.g. <code>initialize_with { new(**attributes) }</code>), those attributes should not refer to <code>instance</code>,
since it will be <code>nil</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
