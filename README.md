NOTE: this documentation is for the beta version of factory_girl 2
==================================================================

Up-to-date documentation for the stable branch can be found here:

(http://github.com/thoughtbot/factory_girl/tree/1.3.x)

factory_girl
============

factory_girl is a fixtures replacement with a straightforward definition syntax, support for multiple build strategies (saved instances, unsaved instances, attribute hashes, and stubbed objects), and support for multiple factories for the same class (user, admin_user, and so on), including factory inheritance.

If you want to use factory_girl with Rails 3, see
(http://github.com/thoughtbot/factory_girl_rails)

Download
--------

Github: http://github.com/thoughtbot/factory_girl/tree/master

Gem:
    gem install factory_girl

Defining factories
------------------

Each factory has a name and a set of attributes. The name is used to guess the class of the object by default, but it's possible to explicitly specify it:

    # This will guess the User class
    FactoryGirl.define do
      factory :user do
        first_name 'John'
        last_name  'Doe'
        admin false
      end
  
      # This will use the User class (Admin would have been guessed)
      factory :admin, :class => User do
        first_name 'Admin'
        last_name  'User'
        admin true
      end
  
      # The same, but using a string instead of class constant
      factory :admin, :class => 'user' do
        first_name 'Admin'
        last_name  'User'
        admin true
      end
    end

It is highly recommended that you have one factory for each class that provides the simplest set of attributes necessary to create an instance of that class. If you're creating ActiveRecord objects, that means that you should only provide attributes that are required through validations and that do not have defaults. Other factories can be created through inheritance to cover common scenarios for each class.

Attempting to define multiple factories with the same name will raise an error.

Factories can be defined anywhere, but will be automatically loaded if they
are defined in files at the following locations:

    test/factories.rb
    spec/factories.rb
    test/factories/*.rb
    spec/factories/*.rb

Using factories
---------------

factory_girl supports several different build strategies: build, create, attributes_for and stub:

    # Returns a User instance that's not saved
    user = Factory.build(:user)
  
    # Returns a saved User instance
    user = Factory.create(:user)
  
    # Returns a hash of attributes that can be used to build a User instance:
    attrs = Factory.attributes_for(:user)
  
    # Returns an object with all defined attributes stubbed out:
    stub = Factory.stub(:user)

You can use the Factory method as a shortcut for the default build strategy:

    # Same as Factory.create :user:
    user = Factory(:user)

The default strategy can be overriden:

    # Now same as Factory.build(:user)
    factory :user, :default_strategy => :build do
      ...
    end

    user = Factory(:user)

No matter which strategy is used, it's possible to override the defined attributes by passing a hash:

    # Build a User instance and override the first_name property
    user = Factory.build(:user, :first_name => 'Joe')
    user.first_name
    # => "Joe"

Lazy Attributes
---------------

Most factory attributes can be added using static values that are evaluated when the factory is defined, but some attributes (such as associations and other attributes that must be dynamically generated) will need values assigned each time an instance is generated. These "lazy" attributes can be added by passing a block instead of a parameter:

    factory :user do
      # ...
      activation_code { User.generate_activation_code }
    end

Dependent Attributes
--------------------

Attributes can be based on the values of other attributes using the proxy that is yielded to lazy attribute blocks:

    factory :user do
      first_name 'Joe'
      last_name  'Blow'
      email { "#{first_name}.#{last_name}@example.com".downcase }
    end
  
    Factory(:user, :last_name => 'Doe').email
    # => "joe.doe@example.com"

Associations
------------

Associated instances can be generated by using the association method when
defining a lazy attribute:

    factory :post do
      # ...
      author
    end

You can also specify a different factory or override attributes:

    factory :post do
      # ...
      association :author, :factory => :user, :last_name => 'Writely'
    end

The behavior of the association method varies depending on the build strategy used for the parent object.

    # Builds and saves a User and a Post
    post = Factory(:post)
    post.new_record?       # => false
    post.author.new_record # => false

    # Builds and saves a User, and then builds but does not save a Post
    post = Factory.build(:post)
    post.new_record?       # => true
    post.author.new_record # => false

If the factory name is the same as the association name, the factory name can
be left out.

Inheritance
-----------

You can easily create multiple factories for the same class without repeating common attributes by using inheritance:

    factory :post do
      # the 'title' attribute is required for all posts
      title 'A title'
    end
  
    factory :approved_post, :parent => :post do
      approved true
      # the 'approver' association is required for an approved post
      association :approver, :factory => :user
    end

Sequences
---------

Unique values in a specific format (for example, e-mail addresses) can be
generated using sequences. Sequences are defined by calling Factory.sequence,
and values in a sequence are generated by calling Factory.next:

    # Defines a new sequence
    FactoryGirl.sequence :email do |n|
      "person#{n}@example.com"
    end
  
    Factory.next :email
    # => "person1@example.com"
  
    Factory.next :email
    # => "person2@example.com"

Sequences can be used as attributes:

    factory :user do
      email
    end

Or in lazy attributes:

    factory :invite do
      invitee { Factory.next(:email) }
    end

And it's also possible to define an in-line sequence that is only used in
a particular factory:

    factory :user do
      f.sequence(:email) {|n| "person#{n}@example.com" }
    end

Callbacks
---------

Factory_girl makes available three callbacks for injecting some code:

* after_build  - called after a factory is built   (via Factory.build)
* after_create - called after a factory is saved   (via Factory.create)
* after_stub   - called after a factory is stubbed (via Factory.stub)

Examples:

    # Define a factory that calls the generate_hashed_password method after it is built
    factory :user do
      after_build { |user| generate_hashed_password(user) }
    end

Note that you'll have an instance of the user in the block.  This can be useful.

You can also define multiple types of callbacks on the same factory:

    factory :user do
      after_build  { |user| do_something_to(user) }
      after_create { |user| do_something_else_to(user) }
    end

Factories can also define any number of the same kind of callback.  These callbacks will be executed in the order they are specified:

    factory :user do
      after_create { this_runs_first }
      after_create { then_this }
    end

Calling Factory.create will invoke both after_build and after_create callbacks.

Also, like standard attributes, child factories will inherit (and can also define) callbacks from their parent factory.

Alternate Syntaxes
------------------

Users' tastes for syntax vary dramatically, but most users are looking for a common feature set. Because of this factory_girl supports "syntax layers" which provide alternate interfaces. See Factory::Syntax for information about the various layers available. For example, the Machinist-style syntax is popular:

    require 'factory_girl/syntax/blueprint'
    require 'factory_girl/syntax/make'
    require 'factory_girl/syntax/sham'
  
    Sham.email {|n| "#{n}@example.com" }
  
    User.blueprint do
      name  { 'Billy Bob' }
      email { Sham.email }
    end
  
    User.make(:name => 'Johnny')

More Information
----------------

* [RDoc](http://rdoc.info/projects/thoughtbot/factory_girl)
* [Mailing list](http://groups.google.com/group/factory_girl)
* [Issues](http://github.com/thoughtbot/factory_girl/issues)
* [GIANT ROBOTS SMASHING INTO OTHER GIANT ROBOTS](http://giantrobots.thoughtbot.com)

Contributing
------------

Please read the contribution guidelines before submitting patches or pull requests.

Credits
-------

factory_girl was written by Joe Ferris with contributions from several authors, including:

* Alex Sharp
* Eugene Bolshakov
* Jon Yurek
* Josh Nichols
* Josh Owens
* Nate Sutton

The syntax layers are derived from software written by the following authors:

* Pete Yandell
* Rick Bradley
* Yossef Mendelssohn

![thoughtbot](http://thoughtbot.com/images/tm/logo.png)

factory_girl is maintained and funded by [thoughtbot, inc](http://thoughtbot.com/community)

The names and logos for thoughtbot are trademarks of thoughtbot, inc.

License
-------

factory_girl is Copyright Â© 2008-2011 Joe Ferris and thoughtbot. It is free software, and may be redistributed under the terms specified in the LICENSE file.
